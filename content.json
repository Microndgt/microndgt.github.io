{"posts":[{"title":"2022年5月","text":"时间流逝之快，超出我的想象。之前好像还能稍微抓住它，现在只能任其飘散。越是这样，我心里会越慌，然后越来越麻木，任其流逝，最终回过头来只能懊悔。我不太喜欢这样快节奏的生活，太空虚，整个人似乎只是为了工作，为了钱而活着，其他方面没有可以想象的空间。 我想去乡村生活，有一片自己的土地，可以种想种的东西，蔬菜瓜果，花草树木，养一些小动物，每天起来读书写字，远离焦虑，然后这样慢下来生活。 不扯这些了，说说这个月实际发生的事情 装修首先这个月开始收房装修了，五一假期的时候就把主材订了，差不多20W吧，然后收房补的面积差价，交的大修基金下来就有快3W了。收房之后等了一个周开始办装修手续，办装修手续又办了一个周，这物业实在是太差劲了，好不容易到5月29日才开工。 开工先搞的事情就是铲素灰，铲保温墙，砸墙，我们改了户型设计，将两个卫生间合并成一个卫生间了，所以砸了不少墙，砸墙就花了1600。这第一步铲砸和运垃圾一共花了4700。 5月整个在装修上做的事情就只有这些了，效率实在是太低了。截至今天，6月1日完成了新风和空调的安装，6月3日开始砌墙，这个砌墙其实就是改卫生间那块的设计，墙砸了还要按设计重新砌一下，估计就到6月4日完工，下来就是水电改造工程。 装修太花钱了，让人感觉就是一个千疮百孔的容器，里面的水（水就好比你的资金）止不住的流，但是你往进加水的速度又太慢了。而且本来以为装修仅仅是花钱的事情，没想到里面要操心的事情太多了，比如地暖会不会漏水，天花板上的下水管道会不会漏水，空调新风打的孔会不会有问题，这些都是之前没有遇到过的问题，心里容易慌。搞的现在花钱都是小问题了，只要顺利完成装修才是我现在心里着重希望的事情。 投资股市方面，本月收益率5%，主要还是两次创业板上车的盈利，其他打野标的也就是赚了亏，亏了赚，对收益率没有啥贡献，主要还是创业板。红利其实也有所表现，只不过当时上的仓位比较少，盈利不多，收益率的话也有2%。现在交易已经省心省力了，我的交易系统已经逐渐稳定成型了。 在市场里持续赚钱，就得去重复那些让自己能赚钱的事儿，避免那些让自己亏钱的事儿和运气主导的事儿。所以得总结，做对的事儿继续做，犯过的错不再犯，业绩就会逐渐提高。我觉得现在就已经走在这条正确的路上了。 现在有一个问题，就是按照交易系统操作，其实会漏掉一部分收益，因为现在的原则就是有收益就止盈，像5月30日到6月2日的这波创业板行情，我是5月30日上车的，5月31日上涨2%，这天的收益全部满仓吃上，然后6月1日挂止盈单清仓，但是6月1日又上涨了快1%，6月2日上涨了2.5%，相当于我少吃了至少3%的收益。 现在似乎确实没有什么解决办法，因为你并不知道一波趋势来了之后，会持续多久。像从2021年12月到现在的创业板走势，大多时候一波趋势也就两三天，我的系统就能完美处理这种情况。再从另外一个角度来看，我现在定的每个月收益率目标是5%，那只要达到我的目标，哪怕少挣点，其实没什么问题，毕竟你不可能把市场的收益吃干榨净。我觉得只要能够实现稳定盈利，慢慢积累就够了，人要是贪婪起来就没完没了了。 另外我除了创业板还会做红利，还有其他标的啊，在创业板转弱的时候，还能继续在红利上取得收益，综合来看其实比创业板的收益差不了多少。所以这个问题其实并不是问题，之所以这个会成为问题，还是人性贪婪。 将来的生活计划6-7月要娃，现在时间一步步接近，但是总是觉得忧心忡忡，比较担心将来有娃之后的生活怎么应对，谁来带娃？ 目前来说最佳方案就是我在家办公，然后请一个保姆仅工作日白天来做饭看娃，这样应该是最好的方案。但是找到一个在家办公的工作确实不易，也不知道我们公司能不能给我搞个特殊。此乃上上策。 如果不能搞特殊，那要么就是我去找个远程的工作，难度比较大。此乃中策。 要么就是我不工作了，我自己看娃，省一个保姆的钱，然后自己靠股市生存，这是下下策。因为没有工作的话，自己的交易心态就会有比较大的影响，具体有多大，没经历过，也不知道。 这仅仅是谁来带娃的问题，其他小问题我想肯定只会多不会少。现在压力真的很大，工作压力：各种被优化，被毕业，工作上还各种卷，上班一天已经筋疲力尽了。经济压力：房租房贷装修，三座大山，我现在房贷+房租一个月1W+。生活压力：很多琐碎的事情你也要去应付，因为没有人帮你做。 这样的情境下，既没心情，没时间消费，也没能力消费。一天天的发消费券，有个P用，能不能直接发钱，让我先把房贷还一下。","link":"/2022/06/03/2022%E5%B9%B45%E6%9C%88/"},{"title":"2022年4月","text":"之前的趋势梭哈系统每月总结决定不再更新了，其一是现在投资策略基本已成，变动不大，也不太需要专门记录了，其二是想在每月总结中加一点其他的内容，比如本月发生的事情，自己的思考等。所以就直接改成每月总结得了。 那首先还是记录一下投资方面的事情，本月收益率5.3%。四月行情非常差，但是没想到四月份是收益最高的一个月 果然危机，危中有机，收益主要来自4月的最后几天，真是柳暗花明又一村。 关于投资策略的一些思考，现在我觉得似乎可以考虑开始建一些长期仓位，但是也只能是非常小的仓位，因为我对当前世界经济形势还是有非常强的担忧的，毕竟现在没有破局之法，除非全球各国之间进行合作，但是这非常难。全球经济大国，中国和美国现在这种基本对立的情况，问题是没法解决的。所以保持长期仓位这个还是得慎之又慎，再继续看看吧，不着急，按照策略的短期操作在2月，3月，4月都取得了3+%的收益率，所以完全不用担心。 4月开始读围城这本书，以前一直在kindle上断断续续的看，一直没有看完，这次是之前凑单买的纸质书，发现看起来非常有感觉，而且感觉很好看。好看的一点原因是我有点浸入到书中的世界了，觉得他们的生活很有意思，估计是因为我自己的生活太乏味了～ 另外一点就是我觉得我挺像方鸿渐的，凡事糊里糊涂没有主见，主要还是内心有点脆弱不够强大，遇到事情第一个想到的可能是逃避。 现在在城市的生活，白天上班，晚上睡觉真的是有点枯燥，然后周末也不知道干啥，百无聊赖，无所事事。五一假期一回到农村，就感觉节奏就慢起来了，似乎大脑神经也放松起来了。说实话，我现在有点想去农村躺平了，种种花，养养动物啥的。一回到城市就感觉神经紧张，各种事情得面对，最近要面对的一个大事情就是装修，真太花钱了，随随便便几十万的花费，为啥一定要在城市高花费低生活质量呢？我现在在这个刚需盘的房子里已经花了200W了，我有这200W去农村生活不好吗？ 工作上，也许是我身体原因吧，反正每天上一天班我眼睛就很不舒服，现在甚至有时候会视野变花，然后等一会才会恢复，眼睛疲惫是常事，表现就是肿胀，酸疼，有时候会痒，飞蚊症越来越明显。去看医生，医生就说少看屏幕，可是现在工作怎么才能少看屏幕呢，之前下班回来还会看会书（电脑上看），或者看会视频，有时候会打游戏，现在晚上回来，一个屏幕都不想看，9点多早早就睡觉了，就这样，每天白天眼睛还依然很难受。我在想，这样的生活质量，我不知道在坚持什么？我真怕啥时候瞎了。 算了，不说这些负能量了，没有意义，抱怨解决不了问题，只有尝试解决才会。","link":"/2022/05/02/2022%E5%B9%B44%E6%9C%88/"},{"title":"Casdoor 部署问题","text":"后端运行时 timeout运行go run main.go，时候报 get 包 timeout，应该是代理问题，解决办法就是：go env -w GOPROXY=https://goproxy.cn,direct 如下： 12345678duguangting@c123:~/casdoor$ go get github.com/RobotsAndPencils/go-saml@v0.0.0-20170520135329-fb13cb52a46bgo: github.com/RobotsAndPencils/go-saml@v0.0.0-20170520135329-fb13cb52a46b: Get &quot;https://proxy.golang.org/github.com/%21robots%21and%21pencils/go-saml/@v/v0.0.0-20170520135329-fb13cb52a46b.mod&quot;: dial tcp 172.217.163.49:443: i/o timeoutduguangting@c123:~/casdoor$ go env -w GOPROXY=https://goproxy.cn,directduguangting@c123:~/casdoor$ go get github.com/RobotsAndPencils/go-saml@v0.0.0-20170520135329-fb13cb52a46bgo: downloading github.com/RobotsAndPencils/go-saml v0.0.0-20170520135329-fb13cb52a46bgo: downloading github.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8dgo: downloading github.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0 前端运行报错后端跑通之后，前端运行yarn install的时候报： The engine &quot;node&quot; is incompatible with this module 解决办法： yarn install --ignore-engines Goland 方法没法跳转在Goland里所有引入的外部包无法跳转，搜了一下，大概这样： step 1 在 Goland 的 go modules 设置勾选，然后设置 GOPROXY step2 然后因为项目已经有 go.mod 文件了，那么直接执行 go mod tidy，这个命令的作用就是：add missing and remove unused modules 然后就 OK 了","link":"/2022/09/21/Casdoor-%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/"},{"title":"FIRE基金策略调整","text":"最近FIRE基金刷新了从2022年2月以来的最大回撤，目前为止为6.18%。 究其原因，并不是操作的问题，而是系统性原因，8月和9月市场行情不太行，导致每次上车都是白给，而中秋节后更是如此，在节后第一天上证50，深红利，银行等诸多标的提示买入信号，最后竟然买入到了满仓，其实那时候觉得应该也会继续上涨，没想到后面连续4天回撤了快3%！ 从9月份系统回测图可以看出来，确实有巨大的回撤。 但是我的目标是最小回撤，稳定复利，高达6%的回撤可是不能接受的，而且这个回撤还不一定会结束 orz… 但是我发现回撤的品种全是之前定位打野的品种，然后我依稀记得之前得出过一个结论，打野基本上不赚钱，赚了亏，亏了赚，对净值只会起波动作用，而不是起增长作用。于是我便去掉打野标的进行了回撤，从2021年3月1日开始： 我惊呆了，标准的上楼梯曲线，一直保持东北角的上升曲线，几乎没有回撤，这不就是我追求的完美资金曲线嘛！17个月的时间，快60%的收益率，一年大概40%的收益率。 再对比下有打野标的的曲线（从2021年12月1日开始） 而对应的2021年12月1日开始的去除打野标的的曲线 两相对比，含打野的在总收益率上略胜一筹，其实也差不多，但是不含打野的避免了大的回撤，减少了波动。最重要的是，省心省力，诸多打野来回操作也挺消耗精力，一直持仓总会不可避免的关注股市。 所以我决定，++以后FIRE基金的策略调整为不做打野标的，只做满仓标的。++ 其实可以想到，如果满仓标的有回撤，那么不论采用哪种都会有回撤，而根据打野的历史经验，打野基本不赚钱，那何必劳心费神呢。 现在基金只有20%的仓位，持仓有两个打野标的，这两个又是买入后就跌，目前亏损幅度还不小，= =!。下来就是等创业板转强，梭哈就完事了。","link":"/2022/09/17/FIRE%E5%9F%BA%E9%87%91%E7%AD%96%E7%95%A5%E8%B0%83%E6%95%B4/"},{"title":"Get新技能——换锁芯","text":"租了个新房子，这个房子之前住的人比较杂，所以需要换一个锁芯。 看了个视频觉得挺简单的，但是实际拆了之后出现了一些问题，因为不是很了解，所以小心翼翼的，现在想来也挺简单的。 首先是用螺丝刀将门锁内侧的两个螺丝拧开，把内侧把手拆掉，然后把门外侧把手拆掉。我这里内侧很好拆，但是外侧不好弄，刚开始以为有什么玄机，后来发现还是要大力出奇迹，来回扭一扭就拆掉了。其实外侧把手相当于一个螺母，内侧把手穿了一个螺丝，通过这种方式连接到一起了。 接下来是把门锁中间固定锁芯的螺丝拆掉，拆掉之后有的锁芯可以直接拔下来，我这边拔不掉，当时我就卡在这里了，后来在网上搜了一下说是插入钥匙拧一下，拧到合适的角度就能拔下来了。拔下来之后才发现，锁芯中间有个小塑料环，拧到一定角度才能和锁芯主体平齐，这样才能拔出来。 锁芯拔出来之后，量一下中间螺丝孔到锁芯两边的距离，然后网上下单，完了把旧锁芯再装回去。 新锁芯回来，按照上面的步骤把旧锁芯替换为新锁芯，装回去，万事大吉。","link":"/2022/09/15/Get%E6%96%B0%E6%8A%80%E8%83%BD%E2%80%94%E2%80%94%E6%8D%A2%E9%94%81%E8%8A%AF/"},{"title":"Casdoor的权限检查","text":"Casdoor 的权限检查机制是基于 Casbin 的，参考文档： Permission Overview Syntax for Models 简要介绍所有在同一个组织的用户可以访问该组织下的所有应用，但是有时候需要做一些限制，这里就要用到 权限(permission) 了。 那么 权限(permission) 的作用就是用于控制 用户 能否对 应用 进行某些 操作 最简单的方式就是在 权限(permission) 配置页面新建一个权限，如下图所示： 作为三个要素，用户，应用和操作，在这里是需要配置的： 包含用户 资源 动作 意义也比较简单，就是哪些 用户 可以对哪些 应用 进行哪些 操作 包含角色 也容易理解，一个角色对应多个人，所以这里就是用来控制一组人的。 那上面的模型是什么意思呢，Casdoor 是如何根据这个配置进行权限校验的呢？ ACL 权限控制模型ACL 权限控制模型应该很熟悉了吧，Linux 上就在使用，这里就不再赘述，参考： Access-control list Access Control List (ACL) Casbin 的权限控制Casbin 是一个开源的权限控制库，它支持了多种权限控制模型 Casbin 实施权限规则比较简单，管理员需要列出 主体(subject)，对象(object) 和期望允许的 操作(action) 即可： subject，主体，比如用户 object，对象，需要被权限控制的对象 action，动作，read，write，delete或者其他定义的动作（操作） 管理员需要定义 模型(model) 文件来确定校验条件，Casbin 提供了一个 执行器(Enforcer) 来根据规则定义和模型文件来校验请求。 也就是说 Casbin 权限校验需要三个部分：模型(Model), 校验规则(Policy)和执行器(Enforcer)。 执行器是 Casbin 自带的，可以不必特别关注，只需要知道这件事情就行。下来着重研究模型和校验规则。 哦，对了进行权限校验还需要一个 请求(request) 模型定义Casbin 里的权限控制模型被抽象成了一个 CONF 文件，基于 PERM metamodel (Policy, Effect, Request, Matchers)，这个 PERM metamodel 基于 4 个部分 Policy, Effect, Request, Matchers，其描述了 资源 和 用户 之间的关系。 Casbin 里最简单的一个模型，也是默认模型： 1234567891011[request_definition]r = sub, obj, act[policy_definition]p = permission, sub, obj, act[policy_effect]e = some(where (p.eft == allow))[matchers]m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act Requestr = sub, obj, act 定义了请求参数，也就是说请求需要三个部分，subject，object 和 action，通俗点讲就是 访问的用户，访问的对象，访问的方法。 这里其实定义了我们应该提供给权限控制匹配函数的参数名和顺序。 Policyp = permission, sub, obj, act 定义了模型的访问策略，其实是定义了在策略规则文档中字段名和顺序 这里还有一种定义：p={sub, obj, act, eft} eft是可以被省略的，eft代表的是策略的结果，比如就是 allow 或者是 deny，如果没有定义的话，读取策略文件的时候就会被忽略，默认会返回 allow Matcherm = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act 请求和策略的匹配规则，这里 r 就是请求(request)，p 就是策略(policy) Effecte = some(where (p.eft == allow)) 就是对策略的结果再次进行条件判断，这里的意思就是只要有一条规则返回的是 allow，那么整个就是 allow 还有这样的定义：e = some(where (p.eft == allow)) &amp;&amp; !some(where (p.eft == deny)) 就是说有一条是 allow 而且 没有 deny 的情况，整个结果是 allow 这里主要是针对多条匹配规则都匹配上的情况做处理的 在 Casdoor 定义权限控制定义模型我们已经了解了模型的定义规则，那么就开始在 Casdoor 上面实际操作一番吧。 模型定义用来针对要控制的 object，访问的 subject 能允许怎样的 action 首先在页面顶部导航栏点击 模型(Model)，点击新增： 模型文本这里就填写上面介绍过的模型定义字符串，点击保存&amp;退出。 定义权限在页面顶部导航栏点击 权限(permission)，点击新增： permission 其实就是具体的控制权限设置，可以针对多个资源进行控制 其实这里的配置界面只是简化了规则的配置，这个页面的权限其实会转换成类似如下的数据： 12p alice data1 readp bob data2 write 代码上 permission 里定义的规则会先转换成 CasbinRule 对象，每一个对象就包含了 Policy 定义的每个字段，之后就会转成如下的字符串： p, built-in/permission-built-in, built-in/app-built-in/admin, app-built-in, read 执行校验模型和权限定义好之后，对应被控制的用户访问被控制的应用时，Casdoor 就会进行加载对应模型和权限进行校验，执行这一工作的叫做 Enforcer 关于 Enforcer 的文档：New a Casbin enforcer 代码分析流程已经分析差不多了，让我们看看代码上是怎么处理的 Casdoor 是在这个函数做权限校验的。用户登陆时候就会调用，当然在任何你想进行权限校验的地方，都可以进行调用。 12345678910111213141516171819202122232425func CheckAccessPermission(userId string, application *Application) (bool, error) { permissions := GetPermissions(application.Organization) allowed := true var err error for _, permission := range permissions { if !permission.IsEnabled || len(permission.Users) == 0 { continue } isHit := false for _, resource := range permission.Resources { if application.Name == resource { isHit = true break } } if isHit { enforcer := getEnforcer(permission) // v2.Enforcer allowed, err = enforcer.Enforce(userId, application.Name, &quot;read&quot;) break } } return allowed, err} 逻辑就是通过 organization 来获取所有的 permission 配置，接下来遍历 permission 中定义的 resource，如果跟当前的应用匹配，那么用这条权限去检查用户是否有对应的权限。 匹配成功之后，调用 getEnforcer 来获取一个执行权限校验的 enforcer。 1234567891011121314151617181920212223242526272829303132333435363738394041func getEnforcer(permission *Permission) *casbin.Enforcer { tableNamePrefix := conf.GetConfigString(&quot;tableNamePrefix&quot;) adapter, err := xormadapter.NewAdapterWithTableName(conf.GetConfigString(&quot;driverName&quot;), conf.GetBeegoConfDataSourceName()+conf.GetConfigString(&quot;dbName&quot;), &quot;permission_rule&quot;, tableNamePrefix, true) if err != nil { panic(err) } modelText := `[request_definition]r = sub, obj, act[policy_definition]p = permission, sub, obj, act[policy_effect]e = some(where (p.eft == allow))[matchers]m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act` permissionModel := getModel(permission.Owner, permission.Model) if permissionModel != nil { modelText = permissionModel.ModelText } m, err := model.NewModelFromString(modelText) if err != nil { panic(err) } enforcer, err := casbin.NewEnforcer(m, adapter) if err != nil { panic(err) } err = enforcer.LoadFilteredPolicy(xormadapter.Filter{V0: []string{permission.GetId()}}) if err != nil { panic(err) } return enforcer} getEnforcer 做的工作就是根据 权限(permission) 数据去看有没有定义好的model，有的话使用定义好的模型文本来加载 enforcer，否则使用默认的模型文本： 1234567891011[request_definition]r = sub, obj, act[policy_definition]p = permission, sub, obj, act[policy_effect]e = some(where (p.eft == allow))[matchers]m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act 加载模型文本之后，enforcer 就会加载对应 权限(permission) 所对应定义的规则，对应 LoadFilteredPolicy 函数。 这些数据加载完成之后，enforcer 会根据传入的 subject，entity，action，即 用户，应用，操作，来检查权限是否允许 allowed, err = enforcer.Enforce(userId, application.Name, &quot;read&quot;) 总结总结一下，主要有以下核心： 理解 Casdoor 的权限是做什么的 理解 模型(Model) 以及 模型文本 是如何定义的 理解 模型，权限是如何配置的，以及是如何对用户，应用进行控制的 理解代码上是如何调用的，可以扩展到其他需要进行权限校验的地方","link":"/2022/09/30/Casdoor%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/"},{"title":"Switch铁人三项","text":"Switch铁人三项就是：健身环大冒险，有氧拳击，舞力全开，这三个我都有，聊聊体验吧。 接触Switch就是从健身环大冒险开始的，而这一切又都是从疫情开始的，在疫情之前从来没有想过还会在家里健身，潜意识里都是健身房，而疫情改变了这一切，改变了人的认知。 健身环大冒险因为疫情爆火，而我也在2020年12月开始Switch铁人三项之旅。 首先是健身环大冒险，做的挺不错，也挺科学的，有氧运动+无氧运动结合，搭配闯关剧情，很容易让人坚持下来，也有趣味性。刚开始的时候因为在家办公，所以我经常玩，后来去办公室上班后，每天下班之后就感觉累成狗，基本上工作日晚上就没玩过几次了，基本上都是周末玩一会。 买了健身环大冒险一个多月后，出了舞力全开这款游戏，当时就是为了尝试体验一下，后来发现这个游戏打开的机会屈指可数，主要还是我没有节奏感，不会跳舞，玩这个游戏就是群魔乱舞，基本上毫无体验感和成就感可言。所以一般玩家可以跳过这个游戏，除非喜欢跳舞。 有氧拳击是最近买的一款游戏，主要特点就是专于有氧运动，一天的运动量在40分钟左右，消耗能量300大卡左右，平均心率在130左右，每次练完一身汗，非常舒服。这款游戏从强度来说没有健身环累，主要是健身环有更多的无氧运动，比如有时候持续深蹲，就非常累，而有氧拳击全程有氧运动，心率很均匀，所以不容易疲劳。 跑步也是一项持续的有氧运动，但是跑步这件事情对于大体重的选手来说非常容易损伤膝盖，所以有氧拳击就是一项非常好的替代品。 后面的健身计划： 第一步，继续有氧拳击，争取每天都能玩一次，加强心肺功能，提高基础代谢水平，然后让体重降下来。 第二步，逐渐开始健身环大冒险，适应一下更多的无氧运动，肌肉训练。 第三步，开始逐步恢复囚徒健身，增大肌肉训练。 至于囚徒健身，之前练过一段时间，后来有所懈怠，后面会再写篇文章介绍一下。","link":"/2022/07/30/Switch%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9/"},{"title":"Tornado 实现的 WebSocket 简单例子","text":"Server 部分，主要就是继承 WebSocketHandler 实现了个 WebSocket Handler 1234567891011121314151617181920212223242526272829303132333435363738394041import loggingimport tornado.webimport tornado.websocketimport tornado.ioloopimport tornado.optionsfrom tornado.options import define, optionsdefine(&quot;port&quot;, default=3000, help=&quot;run on the given port&quot;, type=int)class Application(tornado.web.Application): def __init__(self): handlers = [(r&quot;/&quot;, MainHandler)] settings = dict(debug=True) tornado.web.Application.__init__(self, handlers, **settings)class MainHandler(tornado.websocket.WebSocketHandler): def check_origin(self, origin): return True def open(self): logging.info(&quot;A client connected.&quot;) def on_close(self): logging.info(&quot;A client disconnected&quot;) def on_message(self, message): logging.info(&quot;message: {}&quot;.format(message))def main(): tornado.options.parse_command_line() app = Application() app.listen(options.port) tornado.ioloop.IOLoop.instance().start()if __name__ == &quot;__main__&quot;: main() Client 部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from tornado.ioloop import IOLoop, PeriodicCallbackfrom tornado import genfrom tornado.websocket import websocket_connectclass Client(object): def __init__(self, url, timeout): self.url = url self.timeout = timeout self.ioloop = IOLoop.instance() self.ws = None self.connect() PeriodicCallback(self.keep_alive, 20000).start() self.ioloop.start() @gen.coroutine def connect(self): print(&quot;trying to connect&quot;) try: self.ws = yield websocket_connect(self.url) except Exception as e: print(&quot;connection error&quot;) else: print(&quot;connected&quot;) self.run() @gen.coroutine def run(self): while True: msg = yield self.ws.read_message() if msg is None: print(&quot;connection closed&quot;) self.ws = None break def keep_alive(self): if self.ws is None: self.connect() else: self.ws.write_message(&quot;keep alive&quot;)if __name__ == &quot;__main__&quot;: client = Client(&quot;ws://localhost:3000&quot;, 5) 运行 Server 和 Clinet 之后输出如下： Server 部分 12345[I 220805 10:49:12 server:27] A client connected.[I 220805 10:49:32 server:33] message: keep alive[I 220805 10:49:52 server:33] message: keep alive[I 220805 10:50:12 server:33] message: keep alive[I 220805 10:50:13 server:30] A client disconnected Client 部分 12trying to connectconnected","link":"/2022/08/05/Tornado-%E5%AE%9E%E7%8E%B0%E7%9A%84-WebSocket-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/"},{"title":"WINTER IS COMING","text":"疫情以来的世界，慢慢变的有点失控。 首先疫情已经给世界带来诸多的负面影响了，旅游业受到重创，很多新建景点已经人流稀少，甚至关门大吉，这是最直接可以感受到的。其次每次疫情的爆发都需要大量的社会资源来进行检测，隔离，而且每一次封控都会造成经济活动的停滞，这又反过来减少了社会资源的产出。 最近，上海疫情持续恶化，每天都是几万例，上次听到这个级别的数字也还是疫情初始的武汉，但是过去了这么长时间了，经历了多少次疫情在各个城市的爆发，现在上海依然是防控不住，而且还造成这样的爆发性传染，实在是让人咂舌。从新闻来看，似乎上海就是从0开始防疫，防疫中出现的问题，之前的城市比如西安也都出现过。 国家是时候得发挥中央的优势了，比如组建国家级别的防疫小组，在各地积累经验，然后在爆发疫情的城市指导抗疫工作。另外一码通我觉得也有必要实行全国统一，不能让这些城市各自为战，而是全局统筹规划才行。 刚才看了下高德地图，东部很多地方都出现了因为疫情封路的情况，广州可能又要开始一轮疫情爆发，而西安听说今天已经封了好几个地方。看这架势，今年的经济可能真的没法保住了。 而全球局势也是动荡不安，俄罗斯乌克兰战事依然持续，北约势力还在继续拱火……看看最近的汽油价格，92#都已经快9块了，我也已经一个多月没有加过油了。 如果真这么持续下去，今年下半年或者明年发生金融危机的可能性就非常大了。 那么作为个人，我觉得无非就是想办法增加收入，增加存款，减少开支，减少负债。工作上好好工作，不要轻易辞职，生活上保护好自己的家人。投资上减少股票类型投资，主要做保本的货币类理财。","link":"/2022/04/09/Winter-is-coming/"},{"title":"pip 最佳使用方法","text":"在激活的虚拟环境中使用 pip install 或者 python -m pip install 效果是完全相同的，但是有些场景下就有问题了，而 python -m pip 确保了想要安装的包会和当前解释器是一个环境。 可以设置个别名接着用： 1❯ echo 'alias pip=&quot;python -m pip&quot;' &gt;&gt; ~/.aliasrc","link":"/2022/08/05/pip-%E6%9C%80%E4%BD%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"一个子查询优化","text":"问题背景同事写了一个接口，这个接口涉及到下面三个表： 1234567891011121314151617User: - id - username - created_utc - ...UserLoginInfo - id - user_id - created_utc - ...Project - id - user_id - name - ... 需求是查询出：用户，最近用户登录时间，以及创建的项目数。这里的一条UserLoginInfo记录，代表一次登录，Project就是用户创建的项目记录，可能有多条。 同事实现是用子查询，Python里实现大概如下： 1234567891011121314151617181920212223user_projects_query = ( db_session.query(func.count(Project.id).label(&quot;cnt&quot;)) .filter( Project.user_id == User.id, Project.deleted == 0, ) .label(&quot;user_projects_cnt&quot;))login_utc_query = ( db_session.query(UserLoginInfo.created_utc) .filter(UserLoginInfo.user_id == User.id) .order_by(UserLoginInfo.id.desc()) .limit(1) .label(&quot;latest_login_time&quot;))default_login_query = func.COALESCE(login_utc_query, User.created_utc).label(&quot;default_login_time&quot;)order_mapping = { &quot;login_time&quot;: lambda desc: (default_login_query.desc(), User.id.desc()) if desc else (default_login_query, User.id), &quot;user_projects&quot;: lambda desc: (user_projects_query.desc(), User.id.desc()) if desc else (user_projects_query, User.id), &quot;created_utc&quot;: lambda desc: (User.created_utc.desc(), User.id.desc()) if desc else (User.created_utc, User.id)}query = db_session.query(User, user_projects_query, default_login_query).filter_by(deleted=0).order_by(*condition) 这里的condition是在order_mapping中根据desc的值进行选择的 上面用Python写的代码翻译成raw sql就是 1234567SELECT &quot;user&quot;.id as user_id, &quot;user&quot;.username as user_name, (SELECT count(project.id) AS cnt FROM project WHERE project.user_id = &quot;user&quot;.id AND project.deleted = 0) AS user_projects_cnt, coalesce((SELECT user_login_info.created_utc FROM user_login_info WHERE user_login_info.user_id = &quot;user&quot;.id ORDER BY user_login_info.id DESC LIMIT 1), &quot;user&quot;.id) AS default_login_time FROM &quot;user&quot; WHERE &quot;user&quot;.deleted = 0 ORDER BY default_login_time DESC, &quot;user&quot;.ext_id DESC LIMIT 10 OFFSET 0 分析这一实现一打眼就知道肯定会有问题，因为有很多关联子查询，在数据集小的情况下体现不出来，一旦数据集稍有增大，速度就会大幅下降。因为一般来说，关联子查询在查询优化器里是不好进行优化的，最后出来的算法大概率是Nested loop 下面是在测试环境用explain执行后的结果，果然是Nested Loop占了相当长的时间 12345678910111213141516171819202122232425262728Sort (cost=750000347885.10..750000347885.29 rows=75 width=566) Sort Key: ((SubPlan 2)) DESC, &quot;user&quot;.id DESC -&gt; Bitmap Heap Scan on &quot;user&quot; (cost=8.75..750000347882.77 rows=75 width=566) Recheck Cond: (ext_sys = 1) Filter: (deleted = 0) -&gt; Bitmap Index Scan on idx_user_ext_sys (cost=0.00..8.73 rows=78 width=0) Index Cond: (ext_sys = 1) SubPlan 1 -&gt; Aggregate (cost=19.27..19.28 rows=1 width=8) -&gt; Bitmap Heap Scan on document (cost=4.21..19.25 rows=5 width=4) Recheck Cond: (user_id = &quot;user&quot;.ext_id) Filter: ((user_sys = 1) AND (deleted = 0)) -&gt; Bitmap Index Scan on idx_user_id (cost=0.00..4.21 rows=8 width=0) Index Cond: (user_id = &quot;user&quot;.ext_id) SubPlan 2 -&gt; Limit (cost=10000004618.93..10000004618.94 rows=1 width=4) -&gt; Sort (cost=10000004618.93..10000005141.43 rows=209000 width=4) Sort Key: user_login_info.created_utc DESC -&gt; Nested Loop (cost=10000000000.15..10000003573.93 rows=209000 width=4) -&gt; Seq Scan on user_login_info (cost=10000000000.00..10000000942.95 rows=1045 width=4) Filter: (user_id = &quot;user&quot;.id) -&gt; Materialize (cost=0.15..18.98 rows=200 width=0) -&gt; Index Only Scan using idx_document_user_sys on document document_1 (cost=0.15..17.98 rows=200 width=$) Index Cond: (user_sys = 1)Planning time: 0.212 msExecution time: 229.674 ms 解决那么现在首要问题就是如何避免子查询，可以看到需求里是需要最近用户登录时间和用户的项目数，那么一个很自然的思路就是先把这两个数据查出来，然后再和 User Join到一起进行分页即可，这样就可以避免子查询嵌套到父查询里了，这里涉及到一个子查询的优化方法，尽量将关联子查询上推，上推到和父查询一个层级以避免 Nested Loop。 要实现先查出来某些数据，然后在后面的查询中使用，那么就是 CTE(公用表表达式) 了！公用表表达式，本质是允许用户通过一个子查询语句定义出一个临时表，然后在各个地方都可以使用这个临时表。 实现如下： 12345678910111213141516171819202122232425262728user_projects_query = db_session.query( Project.user_id, func.count(Project.id).label(&quot;cnt&quot;)).filter( Project.user_id == User.id, Project.deleted == 0,).group_by(Project.user_id).cte('user_projects_query')project_count = func.COALESCE(user_projects_query.c.cnt, 0)login_utc_query = db_session.query( UserLoginInfo.user_id, func.max(UserLoginInfo.created_utc).label('login_utc')).group_by(UserLoginInfo.user_id).cte('login_utc_query')login_utc = func.COALESCE(login_utc_query.c.login_utc, User.created_utc).label('login_utc')order_mapping = { &quot;login_time&quot;: lambda desc: (login_utc.desc(), User.id.desc()) if desc else (login_utc, User.id), &quot;user_docs&quot;: lambda desc: (document_count.desc(), User.id.desc()) if desc else (document_count, User.id), &quot;created_utc&quot;: lambda desc: (User.created_utc.desc(), User.id.desc()) if desc else (User.created_utc, User.id)}query = db_session.query( User, document_count, login_utc).join( user_projects_query, user_projects_query.c.user_id == User.id, isouter=True).join( login_utc_query, login_utc_query.c.user_id == User.id, isouter=True).filter( User.deleted == 0,).order_by(*condition) 对应的raw sql如下： 1234567891011121314WITH user_projects_query AS (SELECT project.user_id AS user_id, count(project.id) AS cnt FROM project WHERE project.deleted = 0 GROUP BY document.user_id ), login_utc_query AS (SELECT user_login_info.user_id AS user_id, max(user_login_info.created_utc) AS login_utc FROM user_login_info GROUP BY user_login_info.user_id )SELECT &quot;user&quot;.id AS user_id, &quot;user&quot;.username AS username, user_projects_query.cnt AS user_projects_query_cnt, coalesce(login_utc_query.login_utc, &quot;user&quot;.created_utc) AS login_utc FROM &quot;user&quot; LEFT OUTER JOIN user_projects_query ON user_projects_query.user_id = &quot;user&quot;.id LEFT OUTER JOIN login_utc_query ON login_utc_query.user_id = &quot;user&quot;.id WHERE &quot;user&quot;.deleted = 0 ORDER BY login_utc DESC, &quot;user&quot;.ext_id DESC LIMIT 20 OFFSET 0 在测试环境跑一下 EXPLAIN ANALYSE: 123456789101112131415161718192021222324252627282930313233343536 Limit (cost=2832.33..2832.38 rows=20 width=28) (actual time=11.156..11.162 rows=20 loops=1) CTE user_projects_query -&gt; HashAggregate (cost=31.53..31.88 rows=35 width=12) (actual time=0.103..0.108 rows=26 loops=1) Group Key: document.user_id -&gt; Bitmap Heap Scan on document (cost=9.69..30.69 rows=168 width=8) (actual time=0.018..0.074 rows=181 loops=1) Recheck Cond: (user_sys = 1) Filter: (deleted = 0) Rows Removed by Filter: 29 Heap Blocks: exact=18 -&gt; Bitmap Index Scan on idx_document_user_sys (cost=0.00..9.65 rows=200 width=0) (actual time=0.013..0.013 rows=211 loops=1) Index Cond: (user_sys = 1) CTE login_utc_query -&gt; GroupAggregate (cost=0.29..2760.73 rows=46 width=8) (actual time=1.135..10.853 rows=70 loops=1) Group Key: user_login_info.user_id -&gt; Index Scan using idx_user_login_info_user_id on user_login_info (cost=0.29..2515.61 rows=48932 width=8) (actual time=0.005..5.915 rows=48804 loops=1) -&gt; Sort (cost=39.73..39.99 rows=107 width=28) (actual time=11.155..11.158 rows=20 loops=1) Sort Key: (COALESCE(login_utc_query.login_utc, &quot;user&quot;.created_utc)) DESC, &quot;user&quot;.ext_id DESC Sort Method: top-N heapsort Memory: 27kB -&gt; Hash Left Join (cost=2.78..36.88 rows=107 width=28) (actual time=11.028..11.130 rows=107 loops=1) Hash Cond: (&quot;user&quot;.id = login_utc_query.user_id) -&gt; Hash Left Join (cost=1.28..34.54 rows=107 width=28) (actual time=0.137..0.210 rows=107 loops=1) Hash Cond: (&quot;user&quot;.id = user_projects_query.user_id) -&gt; Index Scan using user_pkey on &quot;user&quot; (cost=0.14..32.67 rows=107 width=20) (actual time=0.014..0.066 rows=107 loops=1) Filter: (deleted = 0) Rows Removed by Filter: 5 -&gt; Hash (cost=0.70..0.70 rows=35 width=12) (actual time=0.119..0.119 rows=26 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 10kB -&gt; CTE Scan on user_projects_query (cost=0.00..0.70 rows=35 width=12) (actual time=0.104..0.115 rows=26 loops=1) -&gt; Hash (cost=0.92..0.92 rows=46 width=8) (actual time=10.887..10.887 rows=70 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 11kB -&gt; CTE Scan on login_utc_query (cost=0.00..0.92 rows=46 width=8) (actual time=1.136..10.875 rows=70 loops=1) Planning time: 0.218 ms Execution time: 11.211 ms 可以看到相比之前的子查询的229ms，使用cte的sql已经降到了11ms了 总结不要在SELECT语句中滥用子查询 子查询只有必要的时候再用，使用时候应该注意考虑如何将子查询与SQL语句的主干进行融合，子查询不是独立的黑盒数据块，应该与主语句通盘考虑后再结合使用。 在使用子查询的地方，往往可以通过CTE表达式进行优化，核心思路就是将子查询提升到和父查询一样的层级，避免Nested Loop，而且CTE表达式可读性更好。 总之在一个SQL有比较多的子查询时候一定要小心，记得 EXPLAIN ANALYSE","link":"/2022/08/24/%E4%B8%80%E4%B8%AA%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"title":"不断的正反馈","text":"炒股嘛，需要不断正反馈才能更有信心 这里就需要高胜率，也就是说干一次成一次，大部分都能成，这样才敢继续干，干了之后心态才能好，才有信心，这是第一步。 保证能成的同时，还需要保证干不成的那次亏损不能太多，不能干成很多次，但是一次干不成就把前面很多次干成的利润全吞掉了，这样肯定不行，因为这样就挣不着钱了。所以光胜率高也没用，需要回撤也低。这里相当于赔率，赔率其实没有明确的定义，而在投资里面可以这样理解，比如盈利可获利40%，反之则亏损20%，那么它的赔率就是40/20=2，所以我们需要保证低回撤其实就是需要保证高赔率。 评价一个策略是否能成就要看它是否是盈利正期望的，而决定是否盈利正期望的就是高胜率，低回撤（高赔率）。 上图是趋势梭哈系统使用组合模式的历史收益曲线，很明显它就是一个高胜率，低回撤（高赔率）的交易系统。这段时间经过实践也能体会到这一点，现在已经执行6次了，每次都是盈利的。 星辰大海，岂不是就在眼前～","link":"/2022/02/09/%E4%B8%8D%E6%96%AD%E7%9A%84%E6%AD%A3%E5%8F%8D%E9%A6%88/"},{"title":"人生的松弛感","text":"最近看到这样一条微博，很有意思。 我想大多数人因为证件过期登不了机，都会生气懊恼大崩溃吧，毕竟从小到大，我们都习惯了掌控生活。 任何计划被打乱，没有按照原本的想象进行，我们都会表现出深深的失望和恐慌，整个人活得特别像刺猬，每根刺都竖立着蓄势待发。 与之相反，面对小孩证件过期的这个突发事故，这个家庭没有揪着不放，没有放大这件事情对行程的影响。 他们很从容地应对当下，没有急切，没有压力，非常轻松地接受着这突如其来的变故，放任其发展，好像一切的发生本应如此，没有什么好气愤，好纠缠。 那一家人的那种人生的松弛感，让博主感动到想哭，我想，这是因为它是这个时代所稀缺的状态，怎能不让人羡慕呢？！ 那到底什么是人生的松弛感呢？ 人生的松弛感，就是面对世界的任何变化和不如意，你都完全接受的状态，爱咋样咋样！ 这个世界的真相，就是所有事情都不是你能控制的。 每一次发生在你身上的事情，有时候在你的预期内，有时候出乎你的意料，但本质上，它的发生都有很多的偶然性和随机性，有很多的影响因素是大脑意识感知不到的。 如果你时刻紧张兮兮地面对生活，期待生活按照你所期望的那样在你眼前展开，那你注定要失望，而当你持续地因此而不开心，患得患失智只会让你的人生走下坡路。 相反，那种人生的松弛感，不是摆烂，不是无所谓，而是与世界的变化和解，跟自己的执念和解，不浪费心力与它纠缠，潇洒转身继续轻松地迎接人生的下一站。 所以，你要转变思路，我们来到这个世界，是来玩的，不设预期，不过多地计划，而是随着变化调整自己，用心体验生活，不急不躁地顺着生命之流而下。 拿工作来说，工作重要吗？当然重要，但是更重要的是我自己开心，所以你不用过度在意别人是怎么看你，不用忧心自己能不能升职加薪，不用过度思考自己怎样才能脱颖而出。 你真正要做的，是追求那种人生的松弛感，让自己用一个放松的心态去工作，不用跟别人比较，不用纠缠于当下的不顺，不用计较付出和回报，而是投入到当下真正该做的事情中去。 很神奇的是，当你的心态彻底转变之后，一切开始变得顺利起来，你在工作中更游刃有余，成就感暴增，瞎逼逼的同事也不常出现在你面前，连老板对你也开始赞赏有加，认可度提升。 这些都是我的亲身体验—— 当你松弛了，你就没有太多得失心，也没有太多的焦虑内耗，你所有的能量都集中在你最需要实现的价值上。 人生的松弛感太难得了，它来自于你对自我的认可，对世界的不期待，以及对人生的负责。 底层的逻辑可能就是“爱谁谁，爱咋地咋地，我只要能自洽通透地过好自己的人生就好！” 为了获得人生的松弛感，我有如下建议： 临在当下，专注事情本身 你需要建立“成长型思维”和“体验者思维”。 “成长型思维”让你在面对过去的事情时认识到自己的不足，看到自身改进的契机，进而不断迭代精进自己。 “体验者思维”则让我们面对未来的生活时，不抱期待，不设预期，而是抱有更多的好奇和探索欲，让自己沉浸在那些该做的事情中。 抱持人生松弛感的人，总是能在过去的坏事中看到好的一面，也不会因为未来的预期而作茧自缚，相反，他们总是可以但行好事，莫问前程。 臣服生活，接纳一切 不拧巴，不较劲，生活不过就是见招拆招。 在《清醒地活》这本书中，作者指出，那些引发我们的执念的人事物，都是束缚在我们心灵的能量。这股被束缚的能量，因为我们的不接纳不臣服，而淤积于我们内心，成为阻挡我们成长的力量。 我们之所以有纠结有内耗，都是因为我们不去放手那些执着的人事物。 如果你放手了，臣服生活，接纳一切，这股被束缚的能量才能被释放。反过来，这股被释放的能量会重新流经你，成为支撑你往上走的意志力。 这时候，你就找到了人生的松弛感。 换句话说，当你不再执着，而是臣服生活，接纳一切，你会有更多的意志力去做好当下该做的事情。 很多人抱怨自己没有意志力去早起，去健身，不妨去审视你是否有太多对生活的执念，以至于你时刻恐慌焦虑，意志力缺失。 了解自己，接纳自己 回归到自身，为了获得人生的松弛感，你需要去了解自己，探索自己。 只有了解自己的人，才会真正地接纳自己，获得人生的松弛感。 你可以看看那些具有松弛感的明星，比如王菲，她应该很清楚自己要什么，很清楚什么对自己最重要，所以当她接纳自己真实的样子的时候，她就可以不惧外界的评判而真实地表达自己，所以我们总是可以看到她呈现给我们的那种淡定从容和那种“爱谁谁”的坦然。 我们对自己人生的定义，不来自于外界的评价体系，而是深深地来自于对自我的了解和接纳，那我们就不会过度地焦虑迷茫，就不会急于自证，不会操之过急，因为只有耐得住漫长的时间线，水到渠成才会是一件非常自然的事情。 人生的松弛感，是生活方式和人生态度由内而外地发散。 它应该成为我们人生的底色，让我们从容淡定地历经岁月的洗礼，并对于所有的体验都保持开放而随性的态度。 人生漫长，一路上会有高潮，也会有低谷。 慢慢地，你会发现，松弛感才是人生的王炸。 共勉～","link":"/2022/08/29/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%9D%BE%E5%BC%9B%E6%84%9F/"},{"title":"以前的hexo博客源码没了","text":"以前的hexo博客源码没了，只能重新开一个了～ 之前搭建的博客服务器到期了，也没有动力继续维护了，算了，然后过期就被收回了 输出其实是个挺耗精力的事情，可能得很久才能攒出一篇正儿八经的文章或者视频 可能还是执行力不太够，现在挖的坑越来越大 想做的事情太多了～ 一件一件来吧 不过博客这个东西最好还是保持持续性吧 后面会把之前的精选文章挪进来 不太喜欢用类似博客网站的东西，觉得太不够私人了 那就从github这个pages重新开始吧 现在有一个宏大的设想，正在一步一步实现，这个过程也会记在这里 慢慢来搞吧","link":"/2022/01/13/%E4%BB%A5%E5%89%8D%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E6%B2%A1%E4%BA%86/"},{"title":"克服中年危机","text":"中产阶级的底座是「假设一切顺利」——这是小概率事件，从风控的角度看，底裤漏风。 现在能取得得高收入，应该多赚一年是一年，保持高储蓄，努力维持，而不是主动打破这种状态。 那么在40岁以前，主要做好三件事： 第一，大幅提高自己的“工资收入”； 第二，对投资有兴趣，开户越早越好，提升自己的投资能力，形成自己的盈利模式； 第三，要有一个好身体，不三高，不熬夜，吃得下，睡得着。 有此三项，保住中产阶级，克服中年危机应该也会有更强的底气了。","link":"/2022/08/19/%E5%85%8B%E6%9C%8D%E4%B8%AD%E5%B9%B4%E5%8D%B1%E6%9C%BA/"},{"title":"写hexo博客的绝佳工具——hexo-client","text":"最近逛Github，发现了一款写hexo博客的绝佳工具——hexo-client，非常好用，在这安利一下。 以前写hexo博客都是用IDE加载整个项目文件夹，在其中编辑，然后利用hexo命令在终端进行操作。有几个地方不是很方便： 上传图片的时候的操作很繁琐，首先需要把图片挪到对应文件夹下，然后在文章里面用markdown语法插入对应的图片地址。 没有markdown的编辑器，有时候一些语法还得现查 没法按照分类和标签来展示文章 IDE编辑完成后，还得在终端去执行发布命令 现在这款hexo-client工具完美解决了上面的问题，它提供了一个很好用的markdown编辑器，如下图： 然后上传图片的时候也很方便，点击编辑器里面的图片按钮，上传即可，工具会自动帮你上传到指定的图片文件夹下，并且会重命名，比如上面这张图片的地址是这样的： ![WX202207301024142x.png](/images/2022/07/30/66ef87ce-a338-4597-9de5-2f3b73084553.png) 很方便有木有，另外首页界面的文章也可以按照分类，标签展示，一目了然： 最后最牛的一点，工具可以一键发布，太爽了有木有： 太好用了，又激起我写博客的热情了，感谢 gaoyoubo！","link":"/2022/07/30/%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BB%9D%E4%BD%B3%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94hexo-client/"},{"title":"写在连续回撤时","text":"最近行情真的很差，一直在跌，账户净值也一路下坡，第一次出现这种情况——连续阴跌。 今天继续跌。。。 策略方面现在完全是按照策略来操作的，只不过新加入了新能车，有色，能源，科创50这四个标的，这四个标的在这一轮每个都是买入后下跌，然后创造出了不少亏损。如果用历史回测来看，加入这四个总收益会有一些下降，收益曲线也会显的不那么平滑，回撤也会增大。这四个部分目前贡献亏损大概在1%左右。 一直在做的标的，这段时间，到目前为止，上证50，红利在亏钱。其他标的倒也还好，深红利还赚了钱。这部分贡献亏损0.3%。 另一方面，账户有一部分长期仓位，大概占比20%，在最近连续下跌的过程中，也贡献了一部分亏损，这部分贡献亏损估计在0.5%左右。 那么如果按照以前的策略来做，现在最多回撤0.3%，而加入了新标的，长期仓位，多亏损了1.5%左右。 这三个部分目前可以优化的部分就是四个新标的买入额度减半，以平滑波动。一直在做的标的暂时不动。长期仓位也暂时不动，现在已经是低位了，向下的概率远小于向上的概率，已经坚持这么长时间了，现在放弃沉没成本有点大。 这是策略部分做的调整。 心态方面我的业绩基准是沪深300，至少现在是跑赢大盘的嘛，有什么可怕的，继续跟随策略。 长期仓位的等上涨的时候又可以吃到涨幅，所以不用担心。 策略目前来说很稳健，虽然说加入的新标的亏损了不少，但是毕竟卖出后一直在跌，那倒也罢了，没有说左右打脸，而且整个市场最近行情真的很差，那我也没啥办法。 只能说慢慢熬吧，等待行情转暖的那一天。","link":"/2022/09/02/%E5%86%99%E5%9C%A8%E8%BF%9E%E7%BB%AD%E5%9B%9E%E6%92%A4%E6%97%B6/"},{"title":"初识 Casdoor","text":"最近工作需要研究了下Casdoor： Casdoor is a UI-first Identity Access Management (IAM) / Single-Sign-On (SSO) platform based on OAuth 2.0, OIDC, SAML and CAS. 简介Casdoor 是一个开源的单点登录系统，单点登录系统的好处就是集中管理用户，使的我们开发的应用只需要关心业务逻辑而不用每个应用都是去实现一套用户系统。 Casdoor 使用了 OAuth2 的方式来完成单点认证，大概逻辑如下图： 总结一下就是： 第一步 获取code 第二步 用code获取access_token 第三步 用access_token获取所需要的资源 安装服务安装文档 文档说的很明白，我这里是下载源码使用的，因为我用的PostgreSQL，所以需要改一下app.conf和adapter.go。 然后后端启动：go run main.go 后端启动： 123cd webyarn installyarn start 非常简单 界面配置这里我是用最小的改动来完成对接demo的，首先需要添加一个组织，组织就是一堆资源，应用的的集合： 后面的用户，角色，权限，模型，提供商都可以先不管，需要了解的可以看文档 然后需要添加一个新的应用，主要就是下图这些 客户端ID和客户端密钥，都是后面对接时候需要的 还有一个就是证书，这个不需要改，只需要点编辑进入将公钥拿到 上面就是在界面上需要完成的事情和完成一个对接demo所需要的数据了 web 对接下面是和 Casdoor 对接的 web 接口代码，主要有两部分，第一部分是获取 code，第二部分是通过 code 获取 access_token，而这个 access_token 已经包含了用户信息，用对应的公钥进行解密，即可得到一个用户的 json 数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import loggingfrom urllib.parse import urljoinfrom casdoor import CasdoorSDK@route(r'/casdoor/sso-login')class CASDoorSSOLoginHandler(BaseHandler): def save_user(self, user_data): user = User.make_user(uid=user_data['id'], ext_uname=user_data['name'], username=user_data['name'], _from='casdoor') return user def get(self, *args, **kwargs): code = self.get_argument('code', None) target_uri = self.get_argument('target_uri') subpath = config.get_config(&quot;webif.redirect_subpath&quot;, '') trident_base = urljoin(self.origin_host, subpath.lstrip('/')) endpoint = config.get_config('casdoor_auth.endpoint') client_id = config.get_config('casdoor_auth.client_id') client_secret = config.get_config('casdoor_auth.secret') org_name = config.get_config('casdoor_auth.org_name') certificate = config.get_config('casdoor_auth.cert') sdk = CasdoorSDK( endpoint, client_id, client_secret, certificate, org_name, ) if code: access_token = sdk.get_oauth_token(code) user_data = sdk.parse_jwt_token(access_token) user = self.save_user(user_data) self.session['proxy_user_id'] = str(user.id) redirect_url = urljoin(trident_base, target_uri) else: origin_url = '{}/api/v1/casdoor/sso-login?target_uri={}'.format(trident_base, target_uri) redirect_url = sdk.get_auth_link(origin_url, state='casdoor') logging.info('redirect to %s', redirect_url) return self.redirect(redirect_url) 配置也比较简单： 这里需要特别注意的是，endpoint 配的是 Casdoor 访问的首页地址，也就是这里是前端地址，而不是后端地址。前端地址是：http://localhost:7001/，后端地址是：http://localhost:8000/，这里很有迷惑性，让我折腾了半天。","link":"/2022/08/04/%E5%88%9D%E8%AF%86-Casdoor/"},{"title":"围城","text":"花了大概一个多星期，读完了围城这本书。 其实在我看来，围城只不过是人的天生逃避罢了，遇到问题就会觉得之前的境况能好一点，其实只要有想逃避的念头，哪里都是围城。 书中有一段话我觉得很有意思： 天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆。 以前我用kindle尝试读过一次，但是没读下去，主要是一开始的内容有点乏味。不过这次反倒觉得越读越有意思，我想了想原因，可能是我觉得里面任意一个人物的生活都比我的生活有意思，我有点浸入的感觉了。。就好像进入了别人的世界，忘记了自己现在枯燥的生活。 另外我感觉我有点像方鸿渐，啥事糊里糊涂没有主见，生活呢也是一塌糊涂，混沌度日，然后自尊心还强。。 有人说，每个人都能从《围城》中找到自己的影子，也许他就是我在本书中找到的影子。","link":"/2022/05/09/%E5%9B%B4%E5%9F%8E/"},{"title":"在 Hexo 博客里插入图表","text":"用到了 Chartjs 的插件：hexo-tag-chart 用法总结如下： 首先在 hexo 博客的目录里运行：npm install hexo-tag-chart --save 然后在文章中就可以使用 chart 的 tag 了 123{% chart 90% 300 %}\\\\TODO option goes here{% endchart %} 其中 chart 是标签名，endchart 是结束标签，不需要更改，90% 是图表容器的相对宽度，默认是 100%，300 是图表容器的高度，默认是按正常比例缩放的，你可以通过设置 options 里面的 aspectRatio 属性来调整宽高比例，另外还有许多属性可以自定义，你可以查看 官方文档。在标签之间的部分，需要自己填充的图表数据和属性。 我自己使用图表的页面：FIRE 基金 参考： 在 Hexo 中插入 Chart 动态图表","link":"/2022/08/13/%E5%9C%A8-Hexo-%E5%8D%9A%E5%AE%A2%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E8%A1%A8/"},{"title":"在这个社会上没有信任可言","text":"2020年的时候我租下了这个房子，本来就是作为新房的过渡期居住，当时就想签三年合同，但是房东说最多只签两年，两年就两年吧，到时候再说。 转眼间到2022年了，房东当时是这么说的 当时我觉得： 签合同房东还得到房子来，我不喜欢被打扰 今年我的房子就装修好了，刚好到明年租房到期住进去，也就一年时间。 现在看来在这个社会上没有信任可言，一切嘴上说的都不可信，落实到文件上才是最真的事情 今天，房东给我下逐客令了，虽然比较委婉，但是就是那个意思。那现在这样对我的损害就是： 本来3200的房租，现在新租房要3500，一个月损失300，6个月损失1800 新找房要半个月中介费，损失1750 还要再搬家，劳心费神 所以我主张房东承担这个损失，但是他不行，他的意思就是他不可能承担这个损失。 我就说当初是你说的因为找中介麻烦，所以没有签合同，我们是基于基本的信任以及租房惯例（默认续期一年）来达成共识的。 但是我也知道，没有合同，我没法主张这个损失，在法理上站不住，因为：根据《合同法》第二百三十六条：“租赁期间届满，承租人继续使用租赁物，出租人没有提出异议的，原租赁合同继续有效，但租赁期限为不定期。“ 不定期的意思就是房东随时可以不租，但是需要提前一个月通知，租客随时可以退租。 当然如果合同里有特殊规定的除外，比如到期后如果没有异议继续续一个合同期。 那现在我的这个情况就是之前合同找不到了，大概率是到期后重新签订合同。现在没有合同，所以就是不定期合同，房东现在的这个要求合法。 那我这里跟他沟通的重点就是 当初是你提出不签合同，我表示信任，也不想让你跑一趟，所以没签。用道德绑架房东，毕竟房东是银行工作人员，还是有一些羞耻感的。 最后达成的结果就是：房东补偿我1000元。 那我也只能见好就收了，然后尽快搬走，省的木乱了。 最后再强调一遍：在这个社会上没有信任可言，一切嘴上说的都不可信，落实到文件上才是最真的事情","link":"/2022/08/17/%E5%9C%A8%E8%BF%99%E4%B8%AA%E7%A4%BE%E4%BC%9A%E4%B8%8A%E6%B2%A1%E6%9C%89%E4%BF%A1%E4%BB%BB%E5%8F%AF%E8%A8%80/"},{"title":"如何去除数学表达式中的无用括号","text":"最近工作上遇到了这个问题，挺有意思，终于遇到了一些有点意思的东西，于是深入研究了下。 问题背景问题大概背景是 系统中会展示数学公式，公式是用树来表达的，以运算符号为节点，比如 3=1+2，首先根节点是=，然后左子节点为3，右子节点是+，接下来+的左子节点是1，右子节点是2，就是以这种方式来表示一个数学公式。 然后展示的时候并不知道哪些地方要加括号，因为括号这个信息隐藏在树里了，展示的时候只能是每个操作符的两边都加上括号，这样展示出来就非常繁琐，那么就得想一个算法来将这些无用括号去除掉。 算法描述算法大概是这样的，只要括号内的非括号部分的数学符号的最小优先级小于括号任意一边数学符号的优先级，那么括号就是必须的，否则就是无用的括号。 比如q * (a * b + c * d) + c，括号内部的+和*，最小优先级是+，括号两边是*和+，小于其中一个*的优先级，那么这个括号就是必须的。 同理，q * (a * b * c * d) + c，这个括号就是无用的。 原理就是括号里面的优先级如果都是高于括号两边，那么不加括号，也是会先计算括号里面的运算。 另外为啥是非括号部分，因为内部如果已经有括号了，那么子括号肯定是先运算了，可以把这个子括号当一个整体对待。 当然目前还有一个问题，就是遇到/和-的时候会有一些问题，比如a/(b/c)或者a-(b-c)，主要原因是/和-有取反的作用，所以需要特殊处理：也就是如果/和-右侧的括号需要保留。 代码实现回到问题背景，按照这样的数据结构，其实算是简化了。结点都是运算符，那么如果把结点左侧作为括号包裹的内容，只需要比较结点左侧的非括号部分最小优先级和结点符号优先级就可以了。同理，右侧也是一样的。 而且针对/和-的特殊处理也更简单了，只需要判断结点运算符是不是/和-，如果是，那么右侧部分需要加括号，当然如果需要的话。 另外代码还实现了一个功能：小括号，中括号，大括号的嵌套。主要原理就是如果某个结点需要加括号，那么递归的去找一下左节点和右节点目前使用的最大括号，在此基础上再用更高一级的括号。 实现代码大概如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class BracketProcessor: small_bracket = 'small' middle_bracket = 'middle' big_bracket = 'big' priority_default = 3 operator_priority = { '+': 1, '-': 1, '*': 2, '/': 2, } def __init__(self, formula_items, expression): self.formula_items = formula_items self.expression = expression self.formula_dict = self.get_formula_dict(formula_items) self.start_node = self.get_start_node(self.formula_dict) self.brackets = { self.small_bracket: 0, self.middle_bracket: 1, self.big_bracket: 2 } @classmethod def get_formula_dict(cls, formula_items): formula_dict = {} for item in formula_items: origin = item.data['origin'] if 'left' not in origin and 'node' in origin: origin.update(origin['node']) if 'name' not in origin: origin['name'] = origin['operator'] formula_dict[origin['index']] = item return formula_dict @classmethod def get_start_node(cls, formula_dict): for key, value in formula_dict.items(): if value.data['origin']['name'] == '=': left_node = formula_dict.get(value.data['origin']['left']) right_node = formula_dict.get(value.data['origin']['right']) return left_node if left_node.data['origin'].get('operator') else right_node return None def process(self): if self.expression and '(' not in self.expression: return # 搜索 left 和 right 的最低优先级 X，Y， # 如果 X 优先级小于 start_node 的优先级，那么 X 需要括号 # 否则，不需要括号 # 对于 Y 同理 # 只在一个分支上检查level # 特例 / - 右边分支如果有同级的 需要带括号 # 括号内部 非括号部分的优先级 self.fill_node_bracket(self.start_node) def ensure_bracket(self, child_bracket): if not child_bracket: return self.small_bracket child_bracket_order = self.brackets[child_bracket] for bracket, order in self.brackets.items(): if order &gt; child_bracket_order: return bracket return None def find_child_bracket(self, node): if not node: return bracket = node.data['origin'].get('bracket') if node.data['origin']['left'] != -1: left_bracket = self.find_child_bracket(self.formula_dict.get(node.data['origin']['left'])) if left_bracket: if not bracket: bracket = left_bracket else: bracket = left_bracket if self.brackets[left_bracket] &gt; self.brackets[bracket] else bracket if node.data['origin']['right'] != -1: right_bracket = self.find_child_bracket(self.formula_dict.get(node.data['origin']['right'])) if right_bracket: if not bracket: bracket = right_bracket else: bracket = right_bracket if self.brackets[right_bracket] &gt; self.brackets[bracket] else bracket return bracket def fill_node_bracket(self, start_node, level=1): start_node_priority = self.operator_priority.get(start_node.data['origin']['name'], self.priority_default) left = self.formula_dict.get(start_node.data['origin']['left']) if left: self.fill_node_bracket(left, level=level + 1) left_lowest_priority = self.get_lowest_priority(left) if left_lowest_priority &lt; start_node_priority: child_bracket = self.find_child_bracket(left) left.data['origin']['bracket'] = self.ensure_bracket(child_bracket) right = self.formula_dict.get(start_node.data['origin']['right']) if right: self.fill_node_bracket(right, level=level + 1) right_lowest_priority = self.get_lowest_priority(right) if right_lowest_priority &lt; start_node_priority or (start_node.data['origin']['name'] in ['/', '-'] and right_lowest_priority == start_node_priority): child_bracket = self.find_child_bracket(right) right.data['origin']['bracket'] = self.ensure_bracket(child_bracket) def get_lowest_priority(self, start_node): if not start_node or start_node.data['origin'].get('bracket'): return self.priority_default node_priority = self.operator_priority.get(start_node.data['origin']['name'], self.priority_default) if start_node.data['origin']['left'] != -1: left_priority = self.get_lowest_priority(self.formula_dict.get(start_node.data['origin']['left'])) node_priority = min(node_priority, left_priority) if start_node.data['origin']['right'] != -1: right_priority = self.get_lowest_priority(self.formula_dict.get(start_node.data['origin']['right'])) node_priority = min(node_priority, right_priority) return node_priority","link":"/2022/09/16/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%97%A0%E7%94%A8%E6%8B%AC%E5%8F%B7/"},{"title":"尘埃落定","text":"生活逐渐回归正轨，一切都开始尘埃落定。这两个月事情实在是太多，而且很多事情不受自己控制，我又是那种想的很多，容易焦虑的人，所以搞的很疲惫。现在终于清净下来了。 换了个新房子住，和之前的房东和房子彻底Say Goodbye，新房子设施出的各种问题都已妥善解决。 装修也基本上快要到尾声了，也顺利通过物业验收，现在还差开关，灯具，厨电，门锁，开荒保洁，窗帘，家具。只要柜子进场就行，可以开始散味，其他的也不是很着急。 除了这两件长时间困扰人的事情，中间还穿插了车在车库被撞，修了2个星期。。 现在慢慢觉得越长大，要处理的事情，要担的事情就越多，为什么不想长大，不就是因为小孩子无忧无虑，不需要扛这些事情，有父母大人护着你。 说起父母，家庭，我还是不知道怎么解决，从今年3月到现在，我没回过老家，也没有跟父母联系过，感觉像是3月份之后，大家不约而同的有一点不好意思联系对方一样，另外我也不知道怎么面对，我想起来就头脑如麻，真的是没有办法。 算了，还是先不想这些事情了，因为想也没有办法解决，还是先把眼前的事情解决好吧。","link":"/2022/09/26/%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A/"},{"title":"我在伊朗长大","text":"这几天疫情又开始蔓延了，所以还是尽量宅在家里吧，宅在家里能做的就是看书，看电视，打游戏，偶尔健个身，虽然看着无聊，但是能看书，看电视，能去了解别人的世界，就已经非常有趣了。 今天又看完了一本书——《我在伊朗长大》，这是一本漫画书，讲的是作者从10岁到24岁，即1980年至1994年间的生活记录。这期间，伊朗在伊斯兰革命之后建立了伊朗伊斯兰共和国，随后与邻国伊拉克打了八年战争，大量戴着天堂钥匙的年轻男孩被送到战场上。作者在1984年14岁时离开伊朗求学奥地利，此时两伊战争正酣。1988年作者回到伊朗，在一度消沉之后，通过国家考试进入大学，1994年毕业后再次离开伊朗。本书虽是作者十四年间的个人成长史或者说是私人生活小史，但透过一个儿童、以及一个离开祖国四年后又重回伊朗并在那里度过四年大学时光的年轻女孩的眼睛来观察伊朗，对于了解伊朗这个政教合一的意识形态国家还是别有一番启示。 伊朗跟朝鲜一样都是一个让人觉得神秘的国家，而伊朗比朝鲜更多的有一种恐怖主义的印象，人们一提起那个波斯古国，真的就是原教旨主义、狂热主义和恐怖主义。宗教并没有错，错的只是人们的利用方式。看这本书让人感觉到是当局一小部分人而非普通民众有这种狂热，想通过这些方式来控制民众，但是这只属于少数极端分子的行为，仍然有一大批为了捍卫自由的斗士，以及受到迫害的普通伊朗民众。 看完这本书，对伊朗有了更进一步的了解。 下面摘录一些觉得有意思的语句： 只有当灾难还能承受的时候我们才会自怨自艾，一旦超越了这个限度，忍受无法忍受的痛苦的唯一办法就是一笑置之。 我的爸爸他们在哪里？为什么他们不能把我搂在怀里安慰我？ 其实我没有什么可哭的。 我只是挽回了自己的尊严。 一年里我第一次感到自豪。我终于明白了外婆的意思，如果我自己不能感到内心的平静，我就永远平静不下来。 人必须教育自己。 生命只有一次，你有责任把它过得精彩。 人可以原谅，但绝不应该忘记。","link":"/2021/08/01/%E6%88%91%E5%9C%A8%E4%BC%8A%E6%9C%97%E9%95%BF%E5%A4%A7/"},{"title":"房子基础装修好了","text":"基础装修：水电木瓦油，也就是房屋水电，吊顶，墙地砖，腻子刷漆 下来是等成品，柜子安装 期待完工的那一天","link":"/2022/07/29/%E6%88%BF%E5%AD%90%E5%9F%BA%E7%A1%80%E8%A3%85%E4%BF%AE%E5%A5%BD%E4%BA%86/"},{"title":"投资切记不要贪婪","text":"曾经的贪婪以我自身来说，很早就定下来了决定要一以贯之的投资策略，但是中间随着时间的发展，来自人天生的原始力量——贪婪，针对这最初的投资策略，做了好几次优化。 但是结果呢，每次优化每次坑，最终还是回到了之前的投资策略上，这中间的资金成本，时间成本，没法算了。 第一次，想能多上几次车，修改了策略的上车和下车条件。巧的是，修改之后第一次执行就遇到亏损情况，这次影响最为深远，亏损幅度也是最大。 第二次，想着能快速的盈利，将不要买股票这条原则忘的一干二净，买了不少股票，而且还是地产银行相关的，随后的事情——保交楼事件，让银行地产相关的股票大幅下挫，但是还好动用的仓位不多，这次亏损幅度较小。 第三次，再一次的修改了策略的上车，下车条件，按道理这次改变其实不算很大，但是恰巧的是，刚一改就遇到不相容的情况，造成了损失，亏损幅度也较小。 综上，三次都是为了多挣点钱，不满足于既定策略的收益情况，做了一些贪婪的决策，最终导致了亏钱，亏时间的事情发生。 这三次比较巧的事情是，每次都是刚修改完，立马就会步入坑中，其实这三个修改，也是多多少少做了些回测的，但是很奇怪，每次修改完，不相容的情况立马就会出现，立马就会造成亏损。 还好的是，每次跳坑之后，切换到原始策略上，很快就又都能回血，但是失去的时间已经一去不复返了。 还有一种贪婪就是不按策略既定的止盈条件来操作，自己觉得还要涨，所以就不卖了，导致本来还能盈利的，后来给亏损了。这种情况的贪婪伤害幅度虽然不大，但是侮辱性极强，很气人。 总结首先如果真的要做优化，最好还是： 第一，使用模拟盘或者小仓位去测试 第二，要经历一个跨度比较长的时间 第三，要严格做出回测 否则，脑袋一拍，就动用大仓位去试错，后果可想而知。 其次严格按策略的止盈止损来操作，既然已经有策略，不按策略来，反而去拍脑袋决策，孰优孰劣可想而知。 最后投资要记的一点：慢就是快，能不断的滚雪球，就是最好的方式。切记不要贪婪","link":"/2022/08/06/%E6%8A%95%E8%B5%84%E5%88%87%E8%AE%B0%E4%B8%8D%E8%A6%81%E8%B4%AA%E5%A9%AA/"},{"title":"投资就像在种树","text":"突然觉得自己的账户就像是精心维护的果园，每一个标的就是一株树，建仓就是埋下种子，凡是要将树种高种大，必须有一套方法，加以耐心，毅力和时间，此后经受无数次风雨，依然坚持不懈，最终才能将树养大，养大之后便可以坐享果实了，正所谓前人栽树，后人乘凉。 对应投资一样，在建仓之后，悉心呵护等待其脱离成本区，有时候会接受大跌的洗礼，但是坚持投资策略，不断的给它输送养分，最终慢慢长大，积累利润垫，等积累足够的利润垫，市值也越来越大的时候，每年分红就够了，没有分红的就需要自己把握高点和低点，高点卖出，低点买入，类似于分红了，这时候就是乘凉的时候。 播种和收获都非常容易，但是用科学的方法呵护并陪伴其长大是一个漫长的过程，这不仅是一个技术活，也是一个考验耐心的体力活，期间不能着急，否则树折腾来折腾去，肯定就折腾死了。 立下种树这个观念，在投资中就不会急躁，不会被各种诱惑吸引，只要老老实实按自己方法种自己的树就可以了，保持耐心，相信将来的某一天终将可以品尝到收获的果实。把投资当成种树，也就是接受投资需要比较长的一段时间来发育，而不是一夜暴富，建立了这个心态，就不会一惊一乍，就会宠辱偕忘，波澜不惊。 我的果园现在有十三棵树，现在都在慢慢长大。树呢分为两类，一种是不太用打理的，它会自己慢慢长大；另一种是短期经常打理的，当然长期的也需要短期打理，但是总体上是省心的。现在大部分都还处于发芽期，而且很多处在风雨飘摇，因为自从种下之后经常都是暴风雨。希望以后情况能好一点，让我的树苗们茁壮成长。目前的目标是树苗们都可以长到10%的利润垫。","link":"/2022/08/14/%E6%8A%95%E8%B5%84%E5%B0%B1%E5%83%8F%E5%9C%A8%E7%A7%8D%E6%A0%91/"},{"title":"投资往往是知易行难","text":"投资说起来简单，但是做起来确实不容易。最大的一个障碍就是如何做到知行合一。 在股市里，知易行难的原因是人们通常低估了赚钱和亏钱时候的心理波动。上涨赚钱的时候高歌猛进，觉得未来一定是涨涨涨，也更加容易发现所谓的利多，所以也容易高位加仓，一把亏光；下跌亏钱的时候，觉得未来前景黯淡，周围也全是利空，所以也容易低位割肉，割完就涨。 而且纵然是你有投资策略，也可能架不住这种心理波动，感觉就像是有个杠杆极度的放大了这个波动，所以很容易出现情绪性的梭哈买入和恐慌割肉。 从另一个角度来看，股市是反人性的，在大家情绪热烈的时候，就需要开始减仓了，在大家情绪低迷的时候，就需要开始加仓了。如果天生可以理性的做到这一点，那么活该你赚钱。但是大部分人都是普通人，都做不到，你可能现在想这么简单，怎么可能做不到，但是事实是，在你真正实盘的时候，在盈亏都是实际的钱的时候，面临这些情况的时候可能真的是做不到的。 所以需要投资策略，还需要对投资策略的信仰。 此外，浸淫在股市这个欲望场里，诱惑很多，欲望也很多，所以另一个很重要的是自己的定力，如何能看到诱惑还能坚持自己的策略，也是一个很值得修炼的品质。","link":"/2022/07/29/%E6%8A%95%E8%B5%84%E5%BE%80%E5%BE%80%E6%98%AF%E7%9F%A5%E6%98%93%E8%A1%8C%E9%9A%BE/"},{"title":"搬家了","text":"中秋节那天开始打包搬家，我真是低估了家里的东西多少，高估了自己的搬运能力。 幸亏把好朋友官哥叫来帮忙了，否则我中秋节三天累死都不可能搬完。 当天打包完成，吃个火锅喝个小酒，吃饱喝足之后晚上干活！ 从晚上8点开始，搬到晚上12点多。 第二天从早上9点搬到中午12点。 真的太累了。 搬完家，开始新生活，加油～","link":"/2022/09/13/%E6%90%AC%E5%AE%B6%E4%BA%86/"},{"title":"斯通纳","text":"这段时间读完了一本书——《斯通纳》，这本书是之前看完《我脑袋里的怪东西》后，在豆瓣上看书评时候发现的。感谢豆瓣，一个让你能发现更多有意思东西的地方，很多书电影都是在通过豆瓣发现的。 《我脑袋里的怪东西》这本书看完后让人有一种力量，一种可以直面惨淡人生的力量，有时候读着读着，就放佛自己就是主人公麦夫鲁特，自己在经历那些生活的坎坷，但是从不放弃。“在这个世界上，我最爱拉伊哈”——麦夫鲁特和拉伊哈的爱情，婚姻也让人觉得感动，幸运的是，在这个世界上，我也有最爱的人。 我喜欢阅读，是因为从中你可以汲取力量，从中可以感受到生命力，感受到别人的世界，感受到那些平凡的伟大，给人前进的动力。 《斯通纳》就是这样一本书，走到斯通纳的世界里，你会觉得一切都是那么平凡且不如意，但是你会感受到斯通纳的坚持，他在平凡里的坚持。 斯通纳自一堂选修文学课为起点， 他的一生就此悄然改变。未来的斯通纳成为了一名大学老师，结婚、生子、教学、退休、衰老、死亡。在他生命的尽头，或许他可以坦然面对这个问题：你的一生，还要期望别的什么吗？ 的确，这就是平凡的生活，但是能从中汲取到面对平凡可能又失意的生活时的力量。 你还期望什么呢？ P.S. 这本书的翻译有点差","link":"/2021/07/26/%E6%96%AF%E9%80%9A%E7%BA%B3/"},{"title":"最近的失误操作","text":"最近操作失误了很多： 创成长低卖，本来长期仓位，由于自己心理原因：怕跌，给卖掉了，卖了之后一直涨。 上证50，深红利低卖高买，也是本来说好的长期持有仓位，却想着做个T，没想到白白把成本T高。 还没有出信号的时候，提前买入上证50，但是当天却没有信号，买后就跌。但是当天有信号的两个标的，没钱买，这两个标的反而大涨。一来一回损失不少。 总结一下原因： 第一、划定为长期仓位的，自己没有信仰，在看盘的时候就想去操作一把，就导致反向操作的发生。以后长期仓位的平时不操作，只在有买入信号和卖出信号的时候操作。 第二、坚定执行策略，按信号买卖，把自己当成机器人即可，减少甚至做到不看盘，减少突发奇想的操作。 以后计划： 补齐上证50，红利，深红利，创成长，双创的长期持有仓位，做股权现金平衡，只在策略信号发生时候操作 坚定执行策略，按照信号买卖 2022年8月23日更新截至今天，昨天错误买入的上证50，已经亏损1%，而如果买入新能车则盈利2.3%，一来一回损失3.3%收益率，啧啧。 2022年8月24日更新今天在-0.29%的时候认亏服输卖掉了，这一波总共损失3.59%的收益率，好吧，也不算太惨重，及时止损。今天幸亏卖掉了，收盘的时候上证50跌1.01%。 2022年8月25日更新MD今天早上也不知道哪里犯抽把红利在1%处给清仓了，后来涨了2.21%，我吐了，而且这个是长期仓位，为啥我要卖呢？？ 以后上面总结的两个原因和计划，切记切记。","link":"/2022/08/22/%E6%9C%80%E8%BF%91%E7%9A%84%E5%A4%B1%E8%AF%AF%E6%93%8D%E4%BD%9C/"},{"title":"有些东西真是违反直觉，实践方能出真知","text":"虽然这个道理很早就知道了，但是知道一个道理远不如你真正遇到的时候震撼 去年年初的时候搞了一套股票交易的趋势系统，截至到现在，这套系统有一些参数需要设定 而这些参数的设定一直都是我脑子里臆想出来的，并没有实际验证过 这次是我前天吃晚饭的时候，突然想到既然现在该有的数据都有，那为什么不去写份代码验证一下呢？ 所以花了一晚上写了一份回测代码，其实也不多，也就100行，不过组织测试数据比较麻烦，因为也有一年的数据了 搞定这些之后，开始运行，然后很快就发现我目前的参数设置和不设置基本没有区别，这让我有点吃惊，于是赶紧修改代码，准备把各种情况测试一下，找一下最优解是什么 跑完之后，我惊讶的下巴都要掉了，以前我觉得不可能赚到钱的参数组合，却在程序中得到的几乎就是最优解，而且广泛适合各种情况，甚至在12月到1月的这波快速下跌中还能挣到钱 我有点恍惚了，我以为是代码写错了，所以一遍一遍的逐句调试，发现它就是实际情况，它就是事实 我不禁感叹到：有些东西真是违反直觉，实践方能出真知！ 那个晚上，我半夜就醒了，心想既然睡不着了，那干脆起来把整个过程完整详细的过一遍，确定一下将来使用的最优参数组合。从凌晨4点多，一直搞到早上8点，我憋出了一篇类似毕业论文一样的文章，详细的记录了我是如何做参数选择的，有图有数据，可谓有理有据 终于，我要找的真相，我要找的东西就在这样的实践中找到了，要是我一直保持我的固有思想，只是用拍脑袋去做决定，一直不去用实践检验，那我可能永远都只能在真相附近兜兜转转了","link":"/2022/01/15/%E6%9C%89%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9C%9F%E6%98%AF%E8%BF%9D%E5%8F%8D%E7%9B%B4%E8%A7%89%EF%BC%8C%E5%AE%9E%E8%B7%B5%E6%96%B9%E8%83%BD%E5%87%BA%E7%9C%9F%E7%9F%A5/"},{"title":"构建你的投资体系","text":"作为一个普通人，最开始的时候需要通过工作不断的积累本金，应付结婚买房生子等等诸多事情，而这些事情都是相当耗费钱的。一旦度过这些所谓的“坎”，工作上也有了不断进步，收入逐渐提高，财富也慢慢的积累起来的时候，就是时候考虑如何用这些积累的财富去创造价值了。 使用资本去创造额外价值就是一种投资，但是投资是有巨大风险的，在没有清楚认识到这些风险之前，不要投资！你要做的就是构建属于你的投资体系！ 这篇文章我先介绍一下自己的投资体系，至于我是怎么一步一步的构建出来的，以后再说。 建立在股票基金上投资体系这件事情范围很大，涉及整个家庭的资金分配，最为人熟知的就是，标准普尔家庭资产象限图 我这里指的是狭义上的投资体系：股票基金这种高风险投资标的上建立的投资体系 基本原则首先我的投资体系里有几个原则： 不买股票，只买基金。其实对于我来说，我的投资体系是建立在基金上的。 建立自己的交易系统并且坚定执行。 体系结构我的投资体系分为 趋势梭哈 和 长期持有 两个部分，但是这两个部分共同点是基于一套交易系统。 这个交易系统是我花了一年时间打造的量化决策交易系统。 趋势梭哈趋势梭哈部分的主要理念就是利用交易系统的信号进行高抛低吸 分为 梭哈标的 和 打野标的 梭哈标的目前就是创业板相关基金，创成长，创业板50，双创，在买入的时候全仓买入。 打野标的就是其他一些宽基和行业基金：上证50，红利，深红利，科创50，能源，新能车，银行，农业，军工，旅游，有色金属。买入的时候只买20%比例。 如何做呢？就是在交易系统提示弱转强的时候买入，在提示强转弱的时候卖出，或者是根据交易系统的止盈条件进行卖出。 长期持有长期持有部分就是长期持有一部分宽基，在低位加仓，在高位减仓，其实总体上就是一个大波段的高抛低吸。 目前持有标的：上证50，红利，深红利，创成长 另外长期持有的一个目标就是积累足够的份额，足够的利润垫，每年赚取分红，红利ETF的分红大概在3%-5%之间，还是可以的。 总结我的投资体系大概就是如此，不必盯盘，因为有量化交易系统。不必焦虑，因为有投资体系。靠时间的力量，慢慢积累。","link":"/2022/08/08/%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%8A%95%E8%B5%84%E4%BD%93%E7%B3%BB/"},{"title":"构建基于 Python 的单元测试","text":"这篇文章记录了如何基于 Python 构建一个 Web 系统的单元测试，涉及一些基本和高级用法。 测试分类 单元测试：单个模块的测试 集成测试：多个模块的测试 功能测试：项目的功能测试 其实就是范围不同，单元测试仅是系统特定一部分的测试，功能测试是将系统作为整体进行测试，集成测试介于两者之间。 单元测试库最常用的是 unittest 和 pytest 继承 unittest 的 TestCase 类来组织单元测试 assert 语句用来检测是否符合预期，而 pytest 提供了一些更强大的 assert 方法 pytest 用来运行测试，它可以使用加强版的 assert，并且它完全支持 unittest 一个简单的单元测试123456789import unittestfrom fizzbuzz import fizzbuzzclass TestFizzBuzz(unittest.TestCase): def test_fizz(self): for i in [3, 6, 9, 18]: print('testing', i) assert fizzbuzz(i) == 'Fizz' 运行： 123456789(venv) $ pytest========================== test session starts ===========================platform darwin -- Python 3.8.6, pytest-6.1.2, py-1.9.0, pluggy-0.13.1rootdir: /Users/miguel/testingcollected 1 itemstest_fizzbuzz.py . [100%]=========================== 1 passed in 0.03s ============================ pytest命令比较智能，它会自动识别单元测试，它假定以这样的名字：test_[something].py 或者 [something]_test.py 命名的模块都包含单元测试。同时它也会搜索子目录。 一般来说，单元测试统一放到 tests 目录下，和应用目录隔离开。 测试覆盖率安装：pip install pytest-cov 运行 pytest --cov=fizzbuzz，可以针对 fizzbuzz 模块运行单元测试以及覆盖率 123456789101112131415161718(venv) $ pytest --cov=fizzbuzz========================== test session starts ===========================platform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: /Users/miguel/testingplugins: cov-2.11.1collected 3 itemstest_fizzbuzz.py ... [100%]---------- coverage: platform darwin, python 3.8.6-final-0 -----------Name Stmts Miss Cover---------------------------------fizzbuzz.py 13 4 69%---------------------------------TOTAL 13 4 69%=========================== 3 passed in 0.07s ============================ 还有以下参数： --cov-branch 针对分支处理，有多少个分支就统计多少次 --cov-report=term-missing 表示以何种方式展示报告，term-missing表示在terminal上展示，并且会额外加上缺少测试覆盖的代码行数，另外一个常用选项是html 在html上展示报告，很清晰，常用。 可以添加注释 pragma: no cover 来跳过该块代码的覆盖率检测 测试参数化使用库 parameterized： pip install parameterized 12345678910111213141516from parameterized import parameterized# ...class TestLife(unittest.TestCase): # ... @parameterized.expand([('pattern1.txt',), ('pattern2.txt',)]) def test_load(self, pattern): life = Life() life.load(pattern) assert life.survival == [2, 3] assert life.birth == [3] assert set(life.living_cells()) == { (10, 10), (11, 11), (15, 10), (17, 10)} assert life.bounding_box() == (10, 10, 17, 11) 也可以使用列表推导式： 12345class TestLife(unittest.TestCase): # ... @parameterized.expand([(n,) for n in range(9)]) def test_advance_cell(self, num_neighbors): 支持多参数： 1234567import itertoolsclass TestLife(unittest.TestCase): # ... @parameterized.expand(itertools.product([True, False], range(9))) def test_advance_cell(self, alive, num_neighbors): 测试异常1234567891011import pytest# ...class TestLife(unittest.TestCase): # ... def test_load_invalid(self): life = Life() with pytest.raises(RuntimeError): life.load('pattern4.txt') Mockingmocking 就是劫持函数或者功能，可以控制返回值或者其他东西的一种功能。在测试中如果对某个函数已经有了详尽的测试，那么在这个函数被调用的地方，就可以用mocking功能，节约资源。 unittest 里的 mock 模块，可以使用 mock.patch_object() 来替换函数或者方法 123456789from unittest import mockclass TestLife(unittest.TestCase): # ... @mock.patch.object(Life, '_advance_cell') def test_advance_false(self, mock_advance_cell): mock_advance_cell.return_value = False # ... 测试 Web 应用最好将测试归集到一个继承 unittest.TestCase 的类里，这样可以公用 setUp 和 tearDown 方法，会有更好的性能，以及更方便。 WSGI 和 ASGI 都有特定的规则用于服务器如何传递到应用的请求。所以我们可以注入假的请求到应用上来模拟，而不用启动真正的服务器。这些 Web 框架都有所谓的测试客户端（test clients）来帮助实现单元测试，不需要任何网络，会向应用传递假的请求。如果 Web 框架没有提供的话，WSGI 应用可以使用 Werkzeug 库，ASGI 应用可以使用 async-asgi-testclient。 比如，Flask 框架可以直接使用自带的 test client: 1234567891011121314class TestWebApp(unittest.TestCase): def setUp(self): self.app = create_app() self.appctx = self.app.app_context() self.appctx.push() db.create_all() self.client = self.app.test_client() def tearDown(self): db.drop_all() self.appctx.pop() self.app = None self.appctx = None self.client = None Tornado 框架可以继承 HTTPTestCase or AsyncHTTPTestCase 类来实现，其中它自带了 HTTPClient 和 AsyncHTTPClient，可以直接使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class BaseTestCase(AsyncHTTPTestCase): def setUp(self): super(BaseTestCase, self).setUp() self.db_session = test_session self.db_session.commit() self.cookie = SimpleCookie() def get_app(self): test_app = Application() return test_app def get_new_ioloop(self): return IOLoop.current() def get_url(self, path): full_path = super(BaseTestCase, self).get_url('/api/v1{}'.format(path)) return full_path def _update_cookies(self, headers): try: cookies = escape.native_str(headers['Set-Cookie']) self.cookie.update(SimpleCookie(cookies)) except KeyError: return def make_response(self, req, resp): response = Response() response.status_code = getattr(resp, 'code', None) response.headers = {k: v for k, v in list(resp.headers.items())} response.encoding = get_encoding_from_headers(response.headers) response.raw = resp response.reason = response.raw.reason response._content = resp.body if isinstance(req.url, bytes): response.url = req.url.decode('utf-8') else: response.url = req.url extract_cookies_to_jar(response.cookies, req, resp) response.request = req return response def send(self, url, method='GET', data=None, json_data=None, files=None, headers=None, **kwargs): if 'follow_redirects' not in kwargs: kwargs['follow_redirects'] = False request = Request(url=self.get_url(url), files=files, data=data, json=json_data) request_data = request.prepare() if headers is None: headers = {} headers.update(request_data.headers) cookie_sting = '; '.join([f'{key}={morsel.value}' for key, morsel in self.cookie.items()]) if cookie_sting != '': headers.update({'Cookie': cookie_sting}) resp = self.fetch(url, method=method, headers=headers, body=request_data.body, allow_nonstandard_methods=True, **kwargs) self._update_cookies(resp.headers) response = self.make_response(request, resp) self.db_session.rollback() return response def get(self, url, **kwargs): response = self.send(url, method='GET', **kwargs) return response def patch(self, url, files=None, data=None, json_data=None): response = self.send(url, method='PATCH', files=files, data=data, json_data=json_data) return response def post(self, url, files=None, data=None, json_data=None, **kwargs): response = self.send(url, method='POST', files=files, data=data, json_data=json_data, **kwargs) return response def put(self, url, files=None, data=None, json_data=None): response = self.send(url, method='PUT', files=files, data=data, json_data=json_data) return response 测试 html 内容没必要全部 match 去做测试，而是可以检查一部分内容是否存在，比如提交按钮是否存在于 html 中，而忽略其顺序等无关信息。 1234567891011def test_registration_form(self): response = self.client.get('/auth/register') assert response.status_code == 200 html = response.get_data(as_text=True) # make sure all the fields are included assert 'name=&quot;username&quot;' in html assert 'name=&quot;email&quot;' in html assert 'name=&quot;password&quot;' in html assert 'name=&quot;password2&quot;' in html assert 'name=&quot;submit&quot;' in html 这样的方式也适合于其他数据量比较大的测试，只需要测试关键部分即可。 提交表单主要问题在于 CSRF token 怎么处理，可以先发一个 GET 请求，然后拿到 token，再去提交表单，这是一种方法。另一种方法就是在测试中禁掉 CSRF 的保护。 1234567def setUp(self): self.app = create_app() self.app.config['WTF_CSRF_ENABLED'] = False # no CSRF during tests self.appctx = self.app.app_context() self.appctx.push() db.create_all() self.client = self.app.test_client() 测试表单验证根据表单验证失败返回的语句进行判断 12345678910def test_register_user_mismatched_passwords(self): response = self.client.post('/auth/register', data={ 'username': 'alice', 'email': 'alice@example.com', 'password': 'foo', 'password2': 'bar', }) assert response.status_code == 200 html = response.get_data(as_text=True) assert 'Field must be equal to password.' in html 测试需要登陆验证的页面有以下几点： setUp 方法初始化用户 login 方法 完成对应测试 Example: 123456789101112131415161718192021222324252627282930313233343536373839# ...import reclass TestWebApp(unittest.TestCase): # ... def setUp(self): self.app = create_app() self.app.config['WTF_CSRF_ENABLED'] = False # no CSRF during tests self.appctx = self.app.app_context() self.appctx.push() db.create_all() self.populate_db() self.client = self.app.test_client() def populate_db(self): user = User(username='susan', email='susan@example.com') user.set_password('foo') db.session.add(user) db.session.commit() def login(self): self.client.post('/auth/login', data={ 'username': 'susan', 'password': 'foo', }) def test_write_post(self): self.login() response = self.client.post('/', data={'post': 'Hello, world!'}, follow_redirects=True) assert response.status_code == 200 html = response.get_data(as_text=True) assert 'Your post is now live!' in html assert 'Hello, world!' in html assert re.search(r'&lt;span class=&quot;user_popup&quot;&gt;\\s*' r'&lt;a href=&quot;/user/susan&quot;&gt;\\s*' r'susan\\s*&lt;/a&gt;\\s*&lt;/span&gt;\\s*said', html) is not None 测试 API 服务器比较简单，因为 API 接口第一涉及范围小，第二返回基本上都是 JSON，容易解析。 123456789101112def test_api_register_user(self): response = self.client.post('/api/users', json={ 'username': 'bob', 'email': 'bob@example.com', 'password': 'bar' }) assert response.status_code == 201 # make sure the user is in the database user = User.query.filter_by(username='bob').first() assert user is not None assert user.email == 'bob@example.com' 参考 How to Write Unit Tests in Python, Part 1: Fizz Buzz How to Write Unit Tests in Python, Part 2: Game of Life How to Write Unit Tests in Python, Part 3: Web Applications","link":"/2022/08/10/%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8E-Python-%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"正念冥想","text":"最近看到一个关于冥想有意思的观点，让我有一种茅塞顿开的感觉。 众所周知，冥想一般都是打坐，然后集中注意力到我们自己的呼吸上，摒弃其他无关的想法，由此来帮助我们提升专注力。 但是想达到这样的条件似乎不太容易，比如家里没有安静的地方，没有充分的整块时间，可能一会有这个干扰，一会有那个干扰，让人很难集中注意力来做冥想。 但是这位up主提出了一个观点就是，所谓冥想，不一定就一定是要静坐二三十分钟，然后集中注意力到自己的呼吸上。在做任何事情都可以开始“冥想”，正所谓专注于当下，也就是专注于当下你正在做的事情上就足够了，比如： 你在路上走路的时候，就专注于走路本身，感受脚和土地接触的力量，感受自己的呼吸和心跳，感受自己出汗的过程，感受空气的流动和变化，排斥掉其他无关想法，这就是一种冥想。 你在做家务的时候，专注于家务本身。 你在倾听别人说话的时候，专注于别人说的话。 也就是说，在做任何一件事情的时候，专注于这件事情本身。 像古代的大僧大儒，为何喜欢扫地，为何喜欢园艺，他们其实就是通过这些事情来提升自己的专注力。 所以不一定非得形式化的静坐二三十分钟进行冥想，随时随地都可以“冥想”，因为我们的目的只是为了提升专注力，而不是冥想这一个形式。 P.S. 视频链接：没时间没条件冥想？都市忙人提升专注力必看","link":"/2022/03/14/%E6%AD%A3%E5%BF%B5%E5%86%A5%E6%83%B3/"},{"title":"用cookiecutter来创建一个自己的代码模板","text":"最近工作上要新建一个项目，又要搬运一些重复代码，这件事情想想都让人有点sick，于是想到搞一个代码模板多好，以后新建项目直接把相关信息一填，直接生成出新的项目，所以想到了cookiecutter。 cookiecutter以前很早就用过了，比如cookiecutter-tornado，cookiecutter-flask 用这些模板生成出来的项目你就会感觉到什么叫做最佳范式，想必大家都读过最佳实践之类的书或者文章吧，这种最佳实践的确会让人感觉很舒服。 Github上其实有很多模板项目，比如上面的tornado，flask，最新的fastapi也有，但是这些都不太满足我的需求，因为我们公司有很多自己定制化的代码，而且我们是前后端分离的，项目也不需要那些前端模板项目。 因此是时候搞一个自己的模板项目了，其实搞一个模板项目很简单，只是个体力劳动。 cookiecutter其实就是利用模板渲染，把需要替换的字符串写成jinja2的形式：{{ project }}，然后cookiecutter执行的时候就是把你在cookiecutter.json预定义的变量在代码里替换一下。非常简单是不是？ 首先随便在Github上找一个现成的模板项目：full-stack-fastapi-postgresql 把这个里面除了{{cookiecutter.project_slug}}目录，都拷贝到你自己的项目里 然后开始修改里面的cookiecutter.json，这里面的变量需要的可以保留，不需要的删掉即可，也可以新加上自己需要的。 然后就是从一个已有的项目把代码复制到{{cookiecutter.project_slug}}目录里，复制完成之后就开始最累人的部分，将在cookiecutter.json定义的变量替换到代码对应地方，比如这样： 123456789import hashlibimport uuidimport peeweefrom fastapi_permissions import Allowfrom playhouse.postgres_ext import BinaryJSONFieldfrom {{ cookiecutter.project_slug }}.common.enums import Rolefrom {{ cookiecutter.project_slug }}.models import BaseModel 所有需要变量替换的地方都写成{{ variable }}的形式，替换完成之后，利用模板生成一个项目，看是否有问题，直到修改的没有问题，大功告成。","link":"/2022/07/29/%E7%94%A8cookiecutter%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"},{"title":"能否武统","text":"不管今晚怎样，反正白天先吃了一记闷棍——亏损2% 😨 目前看到各路消息，似乎一副马上开战的样子 但是我觉得吧，打应该打不起来，那么就有两个分支： 佩洛西不敢去台湾，那双方都当无事发生，不过这也说明美国影响力在下降，但是最开始美国没说要访问台湾，只是台湾媒体渲染起来的，那最终输家就是台湾。 佩洛西前往台湾，我国战机伴飞，飞跃台湾本土，这是另一个突破，输家也在台湾。 总之，我们都是赢了。 那么明天能不能阳包阴，来个大涨！","link":"/2022/08/02/%E8%83%BD%E5%90%A6%E6%AD%A6%E7%BB%9F/"},{"title":"要当爸爸了","text":"媳妇怀孕现在快5周了，之前早孕试纸已经测出来了，今天去医院做了个B超，显示宫内孕，但是还属于比较早的时期，医生让2周后复查。 今年可算是事情比较多的一年了： 交房装修，花钱费力（主要还是精力） 房子租不成了，又得换 怀孕 而这些都得一个人扛着，现在周末我就下厨房给媳妇做饭，还有考虑各种营养搭配，饮食也要健康。今天食谱：早上燕麦杂粮粥+饼+煎鸡蛋+生菜，下午面条+西兰花+胡萝卜+青菜+荷包蛋，晚上蒸了红薯和小南瓜。 目前还未决的事情有： 装修：卡到柜子这里了，等柜子来一装，门一装，插座灯装好，基本就差不多了。不过现在家具还没买，抽空还得去看看。 租房，确定了一家，130平一月4000块，但是家具简单，床是铁艺床，主要是考虑怀孕期间家里通风得好，然后家具少甲醛等有害物质也少。不过得等到9月10日才能搬，最近就先在这里继续狗着吧。 怀孕，最主要是保证媳妇的饮食健康，营养全面，至少得自己做饭吧，做一顿两顿好说，一直做饭洗碗，啧啧，是个挑战。最近疫情又开始肆虐，不知道什么时候是个头，疫情在平时倒也没啥，现在媳妇怀孕期间，就得特别小心了。 将来孩子出生了，就要做抉择了，如果公司能让我在家办公，就可以请一个保姆帮忙打理，要是不行，只能自己上了。经济问题只能期待A股了，希望FIRE基金能够稳定收益才行。哎，走着看吧。","link":"/2022/08/21/%E8%A6%81%E5%BD%93%E7%88%B8%E7%88%B8%E4%BA%86/"},{"title":"赚钱模式","text":"昨晚上跟我媳妇讨论了一下这个问题，感觉挺有趣的，所以记录一下。 首先我们赚钱模式归因为三个变量，时间，赚钱次数，钱的规模。 所谓时间，很好理解，就是你为了赚这个钱自己实际付出的时间。 赚钱次数，就是你花这一份时间能赚多少次钱，比如打工的人一份时间就只能赚一份钱，而写书的一份时间创作一次就能赚多份钱 钱的规模，打工人或者是写书的赚钱规模都是固定的，因为工资是固定的，每本书的价格也是固定的，虽然随着时间都会增长，但是幅度相比起来其实很小，所以可以忽略掉。而对于做投资的这种，钱的规模变大的速率会更高。 由此我们总结了大概五种赚钱模式，以下一一列举 一份时间一份钱的零售模式 时间: 1 赚钱次数: 0~1 钱的规模: 1 这种是最基础的，也是最赚不到钱的赚钱模式。 你花了一份时间，只能赚到一份钱，而这份时间的出卖是没有保证的。类比于实际，就是打零工，你的这份时间只能按一段一段的去零售，有人买你才有钱赚，没人买你就没钱赚，饱了这顿没了下顿。 所以这种模式累积钱的速度是非常慢的，因为不仅单位时间的钱比较少，而且单位时间也可能是无效的，积累不到任何钱。 一份时间一份钱的批发模式 时间: 1 赚钱次数: 1 钱的规模: 1 这种模式是对应于大部分普通打工人的赚钱模式。 不同于上面的零售模式，批发模式相当于你把时间批发卖给了公司，老板，然后公司按照月来给你发工资，这不就相当于把时间打包批发卖出去了。 这种模式相对于零售模式就是避免了无效时间的产生，你的每一段时间都会创造价值，只不过一份时间还是只对应一份钱。相比于零售模式，积累钱的速度有了明显提升。 一份时间多份钱 时间: 1 赚钱次数: n 钱的规模: 1","link":"/2022/02/10/%E8%B5%9A%E9%92%B1%E6%A8%A1%E5%BC%8F/"},{"title":"趋势梭哈系统2022年1月战报","text":"本月是趋势梭哈系统2.0版本实盘试运行的第一个月，但是市场真是太糟糕了，见下图： 这让我想起来去年2月18日的时候，趋势梭哈系统1.0版本刚刚正式上线的时候，从那之后的几个星期也是跌成狗，那段时间实盘亏了快6%，真是非常难受。 没想到这次2.0系统试运行阶段行情就这么惨，而且这次论收益率，甚至比去年的时候跌的还多，本月回撤了7.52%。。。 但是这些亏损中，所有都来源于自己之前躺平的那些仓位，可以看到本月收益率曲线是跑赢创业板指数5%的 为什么能跑赢，就是本月用仅有的流动资金试运行趋势梭哈系统，所带来的收益，减少了一点亏损。 下图为本月趋势梭哈系统2.0版本的收益曲线图，收益3.12% 目前账户已经把之前躺平的割掉了，虽然有点心痛…… 所以下个月也就是年后正式开始实盘跟踪趋势梭哈系统2.0版本的策略～ P.S. 以后每个月更新一次实盘跟踪情况，写一点总结，针对这个月的情况调整下个月的行动。","link":"/2022/01/29/%E8%B6%8B%E5%8A%BF%E6%A2%AD%E5%93%88%E7%B3%BB%E7%BB%9F2022%E5%B9%B41%E6%9C%88%E6%88%98%E6%8A%A5/"},{"title":"趋势梭哈系统2022年2月战报","text":"本月是趋势梭哈系统2.0版本实盘试运行的第二个月，目前来看效果不错，跟策略预计的差不多： 本月实盘收益率3.08%，策略预计收益率3.73% 因为2月份只有3个周，所以比平常的月份收益率会低一点 今年累计收益率-4.68% 3月份有5个周，所以3月份实现2022年扭亏为盈应该问题不大 目前趋势梭哈系统已经升级到2.4版本了，现在基本上是稳定版，然后操作流程也趋于稳定————每天就是等信号买入，等信号卖出，无需自己看盘，省心省力。 当然策略的进一步优化升级，以及其他的一些想法都会去实现验证 继续加油吧～","link":"/2022/02/28/%E8%B6%8B%E5%8A%BF%E6%A2%AD%E5%93%88%E7%B3%BB%E7%BB%9F2022%E5%B9%B42%E6%9C%88%E6%88%98%E6%8A%A5/"},{"title":"趋势梭哈系统2022年3月战报","text":"转眼间2022年四分之一已经过去了，但是2022年还没有扭亏为盈。 不过在3月这种极端行情下，还能保持正收益，并且跑赢指数快10个点，已经非常不错了。 今年累计收益率-0.96% 3月份没有如愿实现扭亏为盈，不过也快了，不出意外，4月份应该就可以实现了。 最近一直在构建自己的FIRE框架 首先是要有足够的存款，其带来的利息能够，保证自己正常生活。按照自己的生活水平，如果排除掉贷款，房租，车位的花费，不出去旅行，正常生活下一个月差不多是4K的花费，如果按照年收益率3%来算，那么就至少需要160W的存款。 剩下的部分就是可以在股市上尝试获取一些超额收益，目前来看我的交易系统可以每月稳定提供3%-4%的收益率，那么其实我只需要25W的本金，就可以获取到1W元的月收益。 如果能达到这两点，那么真的可以找一个小地方躺平了。 但是现在实际情况呢，房子还有房贷，也还没有装修好，还有房租，车位也是租的，这是额外的支出项。然后存款也不够，股市本金也不够，当然交易系统也没有经过长时间的验证，每月稳定提供3%-4%的收益率也不是那么肯定。 所以，所以，现在还是得搬砖，不过还是要想一想，往前走一走。 FIRE也许就这样慢慢实现了。","link":"/2022/04/01/%E8%B6%8B%E5%8A%BF%E6%A2%AD%E5%93%88%E7%B3%BB%E7%BB%9F2022%E5%B9%B43%E6%9C%88%E6%88%98%E6%8A%A5/"},{"title":"雨天漫游","text":"周日无事，跟媳妇开着车随便逛 我们老家的洋芋片夹馍，香太太。 馍中有乾坤，一馍一世界～","link":"/2022/08/29/%E9%9B%A8%E5%A4%A9%E6%BC%AB%E6%B8%B8/"},{"title":"FIRE基金月报(202209)","text":"目前净值：0.9558，较上个月上涨：-6.42% 9月份FIRE基金损失比较大，回撤了6个多点😨。 回撤主要来自： 打野标的，回撤了3%（占比46%） 主线标的（创业板），回撤3.5%（占比54%） 本月操作上没有什么大的问题，主要还是市场行情太差劲。而打野标的每次上车几乎都是回撤，短时间积累了大量回撤。 以前已经发现过这一点：打野标的总是赚了一点然后就赔一点，不是很稳定，总体上的确是可以增加收益的，但是相应的回撤也增大了。 但是FIRE基金的主要目标是，最小回撤，稳定复利。 那么像这个月这样大的回撤肯定是不可容忍的，所以我决定从本月开始不再操作打野标的，只操作主线标的。 这个月有两次创业板主线上车机会，但是结果都是亏损，所以也没能挽救战局 第一次在中秋节前，创成长盈利了，创业板50亏损了，总体上是亏了一点，最终在中秋节前清仓。 第二次在国庆节前，创业板50上车之后有两次机会进行止盈，但是均没有成功，最终亏损，在国庆节前清仓。 确实很难受，但是没有办法，行情就是这样，比较坑爹。 但是放眼2022年至今，主线收益仍然有接近15%，所以继续坚持策略。 希望第四季度能有好的收获。 待从头、收拾旧山河，朝天阙。","link":"/2022/09/30/FIRE%E5%9F%BA%E9%87%91%E6%9C%88%E6%8A%A5-202209/"}],"tags":[{"name":"投资思考","slug":"投资思考","link":"/tags/%E6%8A%95%E8%B5%84%E6%80%9D%E8%80%83/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"casdoor","slug":"casdoor","link":"/tags/casdoor/"},{"name":"FIRE基金","slug":"FIRE基金","link":"/tags/FIRE%E5%9F%BA%E9%87%91/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"健身","slug":"健身","link":"/tags/%E5%81%A5%E8%BA%AB/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"Tornado","slug":"Tornado","link":"/tags/Tornado/"},{"name":"经济","slug":"经济","link":"/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"世界","slug":"世界","link":"/tags/%E4%B8%96%E7%95%8C/"},{"name":"危机","slug":"危机","link":"/tags/%E5%8D%B1%E6%9C%BA/"},{"name":"pip","slug":"pip","link":"/tags/pip/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"cte","slug":"cte","link":"/tags/cte/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"subquery","slug":"subquery","link":"/tags/subquery/"},{"name":"趋势梭哈","slug":"趋势梭哈","link":"/tags/%E8%B6%8B%E5%8A%BF%E6%A2%AD%E5%93%88/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"sso","slug":"sso","link":"/tags/sso/"},{"name":"Chartjs","slug":"Chartjs","link":"/tags/Chartjs/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"装修","slug":"装修","link":"/tags/%E8%A3%85%E4%BF%AE/"},{"name":"交易系统","slug":"交易系统","link":"/tags/%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"pytest","slug":"pytest","link":"/tags/pytest/"},{"name":"冥想","slug":"冥想","link":"/tags/%E5%86%A5%E6%83%B3/"},{"name":"cookiecutter","slug":"cookiecutter","link":"/tags/cookiecutter/"},{"name":"投资","slug":"投资","link":"/tags/%E6%8A%95%E8%B5%84/"},{"name":"趋势梭哈每月战报","slug":"趋势梭哈每月战报","link":"/tags/%E8%B6%8B%E5%8A%BF%E6%A2%AD%E5%93%88%E6%AF%8F%E6%9C%88%E6%88%98%E6%8A%A5/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"}],"categories":[{"name":"碎碎念","slug":"碎碎念","link":"/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"程序员","slug":"程序员","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"投资","slug":"投资","link":"/categories/%E6%8A%95%E8%B5%84/"},{"name":"运动","slug":"运动","link":"/categories/%E8%BF%90%E5%8A%A8/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"}],"pages":[{"title":"FIRE 基金","text":"嗯，是的，我建立了一个基金。就叫它 FIRE 吧，代表我向往的 FIRE 生活。 从2022年8月开始在这里记录基金的成长（每月更新一次） 8月1日累计净值：1.0038 本月净值2022年9月30日 单位净值：0.9558 累计净值：0.9558 累计分红：0 较上月上涨：- 累计上涨（较8月1日）：-4.78% 净值曲线下面是基金从2022年8月开始到现在的净值（累计净值）曲线图： var ctx = document.getElementById('chart6415').getContext('2d'); var options = { type: 'line', data: { labels: [ '2022-8-1', '2022-8-31', '2022-9-30', ], datasets: [ { label: 'FIRE 基金累计净值', backgroundColor: 'rgba(0,0,0,0)', borderColor: 'rgb(255, 99, 132)', data: [ 1.0038, 1.0214, 0.9558, ] }, { label: '沪深300', backgroundColor: 'rgba(0,0,0,0)', borderColor: 'rgb(99, 132, 255)', data: [ 1.0038, 1.0067, 0.9391, ] }, { label: '创业板50', backgroundColor: 'rgba(0,0,0,0)', borderColor: 'rgb(99, 255, 132)', data: [ 1.0038, 0.9801, 0.8646, ] }, ] }, options: { responsive: true, title: { display: true, text: '基金净值曲线' } } }; new Chart(ctx, options); 注： 累计净值：是基金成立以来每天增减量的累加，包含了所有分红的数据。 单位净值：指的是某一天该基金的单位价值，即该基金当天的价格。","link":"/funds/index.html"},{"title":"关于我","text":"大学学的鱼雷发动机， 读了一年博士， 转行去做了程序员， 后来写了一个交易系统， 所以又开始做交易了， 。。。 人生就是这样，有无限可能～","link":"/about/index.html"}]}